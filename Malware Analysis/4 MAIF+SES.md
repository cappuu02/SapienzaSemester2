# The goal of malware analysis
Depp understanding on how malware works is crucial for:
1. Monitoring and attack prevention
	- identify recurring attack patterns
	- Build rules for monitoring and intrusion detection
	- Design IT systems that more resilient to forthcoming attacks

2. Incident response
	 - Understand what exactly happened
	- Identify all compromised assets (machines, files, etc.)
	- Contain further expansion of the attack
	- Eradicate the attack
	- Recover efficiently

Dissecting malware to understand:
**_How it works_**
- Know your enemy’s strategies
**_How to identify it_**
- Extract signatures/IoCs (Indicators of compromise)
- Prevent further similar infections
**_How to defeat or eliminate it_**
- Rollback (if possible) its effects
- Clean the infected system

==NIST Incident Response Cycle==
![[MW14.png]]

# Signatures
**_Host-based signatures_**:  Identify files/processes/registry keys on a victim computer that indicate an
infection.
**_Network signatures_**: Detect malware by analyzing network traffic (Does the malware inspect the surroundings? Does the malware contact an external Command & Control (C&C or C2) server?).  More effective when coupled with malware analysis. 
**_Behavioral signatures_**: Focus on what the malware does to the system, not the malware itself ( Behavioral analysis. Different from your standard antivirus signature!)

```ad-warning
Be conscious about the risks you are going to face:
You will be asked to dissect malicious software that is designed to harm
computers (possibly your one).  You may need to run such malicious software in order to understand how it works.

Some of the code you’ll inspect have been designed by criminals
Some IPs referenced in some malware may possibly be live. You must assume that behind that IP there is a criminal

```

```ad-important
Stay safe:
- Keep a safe offline backup of your important data
- Always perform analysis on a virtual machine isolated from your main host
- Disconnect the virtual machine from the network unless netcomms are necessary
- If you find references to external IP addresses NEVER EVER try to directly
contact them

```

# Static Vs Dynamic Analysis
==Static Analysis==: Examine the malware without running it 
- **_Tools_**: strings, PE inspection tools, a disassembler like IDA Pro, etc)

==Dynamic Analysis==: Run the malware and monitor its effects. Use a virtual machine and take snapshots.
- **_Tools_**: RegShot, Process Monitor, Process Hacker, CaptureBAT, debuggers,…
- RAM Analysis
# Basic Analysis
==Basic Static Analysis==: Observe the malware without looking at its code
- Tools: strings, PE inspection, etc... 
- Quick and easy but fails for advanced malware and can miss important behaviour

==Basic Dynamic Analysis==:  Easy but requires a safe test environment but is not effective on all malware.
# Advanced Analysis
==Advanced Static Analysis==: Reverse-engineering the malware code with a disassembler. Complex, requires understanding of assembly code and how such code interacts with the OS.

==Advanced Dynamic Analysis==:  Run code in a debugger. Examines internal state of a running malicious executable and how such state evolves.

# Malware Analysis Process
![[MW15.png|400]]

# Expected Behaviors

==Persistence==
The malware installs itself in the system and it performs actions to guarantee its survivability to reboots, inspections and others... Often modifies the OS configuration and the changes are hidden.

==Uniqueness==
Malware is often incompatible with itself, multiple concurrent executions are meaningless or sometimes dangerous for the malware itself. ( Think about two ransomware instances competing for the same resources). Checks at startup guarantee the execution of a single copy

==Environment checks / Targeting==
Malware is designed to work in appropriate environment. Checks at startup if specific execution conditions are met:
- time/date
- Localization
- Availability
- Presence of specific resources 
- Presence of other processes

==Obfuscation and evasion==
Malware will try to hide its presence and its effects to stay undetected as long as possible.
It may inject code in other processes to conceal its real identity
It may mangle its internal code to hide easily discoverable hints of its malicious nature
It may leverage techniques to hamper the possibility to correctly analyse its behaviour

==Fingerprinting & beaconing==
Malware will inspect the infected system and collect information about it
Information can be used to “publicize” its presence to a remote server

==Communication==
Malware often interacts with external command & control services to
-  receive instructions and commands
- update its internal components
- exfiltrate data
Communication may use heterogeneous links types
Data on channels is often obfuscated


```ad-important
title: Important for the Exam

Don’t Get Caught in Details, You don’t need to understand 100% of the code, just focus on key features.
Try Several Tools:
- if one tool fails, try another one
- Don't get stuck on a hard issue, move along
```


# Basic Static Analysis
Techniques:
- Antivirus scanning
- Hashes
- A file’s strings, functions, and headers


# Hashing samples
`MD5 or SHA-1`
Condenses a file of any size down to a fixed-length fingerprint, Uniquely identifies a file:
- There are MD5 collisions but they are not common
- Collision: two different files with the same hash
De-facto standard way of uniquely identifying samples

Most operating systems provide md5 as a standard utility, If you use Windows you may prefer a GUI-wrapped version:
![[MW16.png]]

# Hash Uses
Label a malware sample 
Share the hash with other analysts to identify malware 
Search the hash online to see if someone else has already identified the file 

Interesting alternative: import-hash 
Calculate hash on the set of imported functions from libraries 
Useful to cluster similar samples in a single family 
The idea is that similar versions of a same malware will probably use the same APIs 

# Strings
Any sequence of printable characters is a string. String are terminated by a `null` value (0x00).
Ascii characters are $8$ bits long.

```ad-example
![[MW17.png]]

```

Unicode characters are 16 bits long, Microsoft calls them "wide characters"

```ad-example
![[MW18.png]]

```

## The string command
Native in Linux/OSX, it is also available for Windows. Finds all strings in a file 3 or more characters long.
- Bold items can be ignored
- (1,2) GetLayout and SetLayout are Windows functions
- (3) GDI32.DLL is a Dynamic Link Library
- (4) looks like an IP address
-  (5) looks like an error msg 

![[MW19.png]]

# Obfuscation Through Packing
The code is compressed, like a Zip file. This makes most strings and instructions unreadable.
All you'll see is the wrapper – small code that unpacks the file when it is run.

![[MW20.png]]

==Detecting Packers with PEID==: Tools like PEiD can be used to detect packers. WARNING: Some PEiD plugins may silently run the malware to identify the packer, making it crucial to ensure the testing VM is isolated.

# File execution in Windows
What happen when you double click an executable file in Windows? The OS (actually the loader) looks in the file to understand what to do.What’s in the file?
- Code
- Data
- Other Resources
- Metadata

>All these information need to be organized to be correctly interpreted by the loader.

## The Portable Execution File Format
The PE format is a data structure containing the information necessary for Windows to load and execute a file. It is used by Windows executable files, object code, and DLLs, meaning EXEs and DLLs are treated in a very similar way. Almost every file executed on Windows is in PE format.

The PE file starts with the **_MS-DOS Header_** + Stub (for compatibility). This is followed by the PE headers (containing metadata) and the Section Table. The content is structured in "sections," with the Section Table describing these sections.

![[MW21.png]]

PE files usually contain at least two sections. Sections that are most commonly present include:
- **_Executable Code Section_**: Named .text (Microsoft) or CODE (Borland).
- **_Data Sections: Named_** .data, .rdata, or .bss (Microsoft) or DATA (Borland).
- **_Resources Section_**: Named .rsrc.
- **_Export Data Section_**: Named .edata.
- **_Import Data Section_**: Named .idata.
- **_Debug Information Section_**: Named .debug.

The names of the sections are actually irrelevant as they are ignored by the OS; they are present only for programmer convenience. Consequently, very different names may be found, as packers often use their own names.

## DOS HEADER + STUB
The DOS header occupies the first 64 bytes of the file. Its presence allows DOS to recognize the file as a valid executable and run the DOS stub. The DOS stub usually prints the string: "This program must be run under Microsoft Windows".

- The DOS "magic" signature is 5A4Dh ("M Z").
- The field e_lfanew (at offset 0x3C) points to the PE Header.

![[MW22.png]]
![[MW23.png]]

## PE HEADER
The PE Header begins with a Signature whose value is always 50450000h ("PE"), taking up 4 bytes. The header is composed of three main parts:

1. COFF FileHeader (20 bytes): 
	- Contains the NumberOfSections field.
	- Contains the TimeDateStamp, which shows when the executable was compiled. This date can sometimes be wrong or faked (e.g., all Delphi programs may show June 19, 1992).
	- Contains Characteristics flags which dictate whether the PE file is an executable or a DLL.

2. OptionalHeader (224 bytes): This section contains Standard COFF fields and Windows-Specific fields. Key fields include:  
	- AddressOfEntryPoint (RVA): The Relative Virtual Address (RVA) of the first instruction to be executed.
    - ImageBase: The preferred load address for the file in memory. In 99% of cases, this is 400000h.
	- SectionAlignment: The granularity of section alignment in memory. If the value is 4096 (1000h), each section must start at a multiple of 4096 bytes.
	- FileAlignment: The granularity of section alignment in the file on disk. If the value is 512 (200h), each section must start at a multiple of 512 bytes.
	- SizeOfImage: The overall size of the PE image in memory. It is the sum of all headers and sections aligned to SectionAlignment.
	- SizeOfHeaders: The size of all headers plus the section table. This value can also be used as the file offset of the first section in the PE file.
	- Data Directories (128 bytes): Structures pointing to critical information such as the Export Table and Import Table.

![[MW24.png]]

## PE HEADER - SIGNATURE + FILE HEADER
![[MW25.png]]
## PE HEADER - OPTIONAL HEADERS
![[MW26.png]]![[MW27.png]]

## PE HEADER - SECTION TABLE
The Section Table follows the Optional Header. It consists of one 40-byte record for each section defined in the file.

Key fields in each Section Table Record:
- **_Name_**: Section name.
- **_Virtual Size_**: Size of the section once loaded in memory (how much space the loader will allocate for it).
- **_Virtual Address (RVA)_**: RVA of the section.
- **_Size of Raw Data_**: The size of the section's data in the file on disk.
- **_Pointer To Raw Data_**: Offset from the file's beginning to the section's data.
- **_Characteristics_**: Flags indicating properties, such as whether the section contains executable code, initialized/uninitialized data, and whether it can be written to or read from.

After the section headers we find the sections themselves.
- **_On Disk_**: Each section starts at an offset that is a multiple of the FileAlignment value. There will be 00 byte padding between each section’s data.
- **_In RAM_**: When loaded into RAM, sections always start on a page boundary. This alignment value is stored in SectionAlignment. On x86 CPUs, pages are 4kB aligned; on IA-64, they are 8kB aligned.

# LOADING IN MEMORY 
![[MW28.png]]
The PE header lists libraries and functions that will be loaded. Their names can reveal what the program does (e.g., URLDownloadToFile indicates a program downloads something).

# Imports and Exports
Imports are functions used by a program that are stored in a different program, such as a library.
- DLLs export functions.
- EXEs import functions.
- Both imports and exports are listed in the PE header. Exports should be rare in EXEs.

## Linking Methods
Programs connect to libraries via three methods:
1. ==Static Linking==: Rarely used for Windows executables (more common in Unix/Linux). All code from the library is copied into the executable, making it large in size but self-contained.
2. ==Dynamic Linking==: The most common method. The Host OS searches for the necessary libraries when the program is loaded.
3. ==Runtime Linking==: Unpopular in friendly programs, but common in malware (especially packed or obfuscated). It is also used by software that allows dynamic loading of plugins. Connection to libraries happens only when needed, not when the program starts. This is most commonly done using the `LoadLibrary` and `GetProcAddress` functions.

## Tools and Examples
- **_Dependency Walker_**: Shows dynamically linked functions. Normal programs have many DLLs, but malware often shows very few due to runtime linking.
- **_Keylogger_**: A typical keylogger imports User32.dll and uses the function SetWindowsHookEx, a popular way for keyloggers to receive keyboard inputs. It might export functions like LowLevelKeyboardProc or LowLevelMouseProc to send the data elsewhere, and use RegisterHotKey to define a special keystroke (like Ctrl+Shift+P) to harvest the collected data.
- **_A Packed Program_**: Will show very few functions, as all that is visible is the unpacker.
- **_Resource Hacker_**: A tool that allows analysts to browse the .rsrc section for strings, icons, and menus.