>In this course we will use the Intel syntax
# x86
Reverse engineering of binary code is difficult. 
Thankfully, only some portions of a malware sample really require it 
==FACT==: malicious code $\not =$ compiler-generated code 
- hand-written sequences 
- self-modifying code 
- subtle semantics (e.g., jump in the middle of an instruction) 
- obfuscation of control and data flows 
- other decoys

## DECOMPILATION?
Decompilers (e.g., Ghidra, Hex-Rays) try to reconstruct a high-level C-like representation of a binary code fragment.
**Process far from perfect **
- information loss during compilation (e.g., types, identifiers) 
- decompiling obfuscated code returns an obfuscated source 
- anti-analysis techniques ▪Nevertheless, helpful for reverse-engineering professionals

## CPU and Memory Basics
![[MW4.png]]
RAX, RBX, RCX, RDX: Those are the registers where normally you put your data to have the CPU work on this data.
## ISA AND X86
==Instruction Set Architecture (ISA)== = abstract model describing what a programmer should know to program the machine. (Language of the CPU)

==ISA== ≈ interface between software and hardware. Humans or compilers produce ISA-conformant assembly code, then an assembler encodes it in a binary format understood by hardware 

- Intel defined the x86 ISA for its 8086 processor (1976-1978) 
	- Later extensions preserved backward compatibility 
	- Today most malware is still 32-bit 
	- x86 is also known as IA-32 
	- x86-64 (x64 for short) is the 64-bit successor 

## WORD SIZE AND ENDIANNESS
A word is the natural data unit for a specific CPU design. For x86 processors, the word size is 32 bits
However, for backward compatibility, x86 instructions assume a word operand to be 16-bit long, while a dword operand is 32-bit long. IA32 common data types: byte, word, dword
Memory always operates at byte level. Endianness specifies how multi-byte sequences are read from/written to memory.

![[MW5.png]]

>In the first, the most important word is "AB".

```ad-info
Intel is little endian.
The others are big endian.

```


word us 16-bit,to refers to 32 we have to say "double word", to refers to 64 we have to say a "quad-word". The concept of word is 32'bit then in assembly there is the subtle difference.

## REGISTERS
Coders use (many) variables. CPUs work on (few) registers 
Registers hold data with fast access time:
	==General-purpose registers (GPRs)== can store data or memory addresses 
	==Status register== holds truth values on the state of the processor after the last executed instruction (used, for example, in conditional computations) 
	==Program counter== holds the address of the instruction being executed 
	Many other registers 
x86 general-purpose registers are 32-bit wide

### ACCESSING REGISTERS
![[MW6.png]]

If i want the entire register i should call it by this name for entirely: EAX (E significa extended, perché inizialmente prendere tutto il registro, che era a 16-bit, significava prendere l'intero contenuto ovvero AX. La E, sta per extension e permette di prendere anche gli altri 16 bit aggiuntivi).

```ad-important
==Status== and ==program counter== registers, there is no way to modify them directly!

```

>H stay for higher and L stay for lower

>Registers are 32-bit

## INSTRUCTION CYCLE
 Fetch-decode-execute cycle: 
 - ==Fetch (prelievo dell’istruzione)==
    - La CPU prende dalla memoria l’istruzione che si trova all’indirizzo contenuto nell’**EIP** (Instruction Pointer, oggi chiamato **RIP** nei sistemi a 64 bit).
    - EIP quindi indica sempre **dove si trova la prossima istruzione**.
- ==Decode (decodifica dell’istruzione)==
    - L’**unità di controllo (Control Unit)** interpreta l’istruzione prelevata, cioè capisce che operazione bisogna fare.
    - Qui si distinguono gli **operandi** (su cosa lavorare) e l’**opcode** (che operazione svolgere).
- ==Execute (esecuzione)==
    - L’istruzione viene eseguita: può essere un calcolo fatto dall’**ALU** (somma, sottrazione, ecc.) oppure un trasferimento di dati (da memoria a registro, da registro a registro, ecc.).
    - Al termine, l’**EIP** viene aggiornato all’istruzione successiva, a meno che l’istruzione non cambi esplicitamente il flusso (es. `jmp`, `call`, `ret`).
 Then EIP advances to the next adjacent instruction, unless current instruction explicitly altered the control flow (e.g., with a jump)

```ad-example
> “The letters A, P, P, L, E, that’s an instruction...”

Immagina la memoria come un libro scritto in **byte** (sequenze di 8 bit).

- Se la CPU legge i primi 5 byte `41 50 50 4C 45` (che corrispondono in ASCII ad “APPLE”), quello è il **fetch**.
    
- Poi la CPU **decode**: riconosce che quei byte hanno un significato come istruzione.
    
- Infine **execute**: compie l’azione richiesta da quell’istruzione.
    

Quindi la CPU non vede lettere o parole, ma **sequenze di byte** che hanno senso solo secondo il set di istruzioni (ISA, Instruction Set Architecture).

```

 Instructions vary in size (1-15 bytes) and are stored consecutively in memory along with any immediate operands (i.e., data or addresses) they might use. Register operands are embedded instead in the opcode binary representation:
 
```bash
b8 01 00 00 00 mov eax, 0x1 
bf 01 00 00 00 mov edi, 0x1 --littleendian
```

`b8` è l’**opcode** che significa “muovi un valore immediato dentro `eax`”.
I 4 byte successivi `01 00 00 00` rappresentano il numero **0x1** in **little-endian** (cioè byte meno significativo per primo).
Quindi tutta l’istruzione occupa 5 byte. Allo stesso modo:
`bf` è l’opcode che significa “muovi un valore immediato dentro `edi`”.
Segue il valore immediato `01 00 00 00`.

# MEMORY ADDRESSING
Addressing modes provide a way to express the addresses of data to be read from/written to the main memory.
Expressions can take immediate operands, registers, or both.
Addressing modes enable operand combinations to compute complex expressions that depend on the program state.
Usually, an instruction can have at most one memory operand.

>We cannot have the same operation that read and write in the same time.

## COMMON ADDRESSING MODES
Some popular ways to specify data to be read from/written to the main memory. For the last two rows, the offset field is optional.

| Mode                      | Intel Syntax             |
| ------------------------- | ------------------------ |
| Immediate                 | Mov eax, $[0x1000]$      |
| Register                  | mov eax,$[esi]$          |
| Register + Offset         | mov eax,$[esp-8]$        |
| Register*width + Offset   | mov eax, $[ebx*4+0xff]$  |
| Base + Reg*width + Offset | mov eax, $[edx+ebx*4+8]$ |
>Ogni volta che, analizzando la memoria, vedo le parentesi quadre significa che sto accedendo alla memoria.

```ad-example

In the first line of the table, we are moving into the register A what is written in memory at address $[0x1000]$.
```

## INTEL VS. AT&T SYNTAX
x86 assembly has two main syntax types: AT&T and Intel. Intel syntax is dominant in the Windows world. Relevant differences:

![[MW7.png|400]]

## MEMORY MAP OF A PROCESS
It illustre how a windows process for a program is orchestrated!

Quando lanci un programma su Windows, il sistema operativo crea un **processo** e gli assegna uno **spazio di indirizzamento virtuale**.  
In architettura a 32 bit, questo spazio è di **4 GB (2³² indirizzi)**. Windows lo divide in:
- **2 GB inferiori (0x00000000 – 0x7FFFFFFF): spazio utente**
- **2 GB superiori (0x80000000 – 0xFFFFFFFF): spazio kernel** (non mostrato nell’immagine).
Quello che vedi è una **mappa semplificata** della metà “user space”.

![[MW8.png]]

>Grey area are inaccessibile!

==Stack==: Parte dall’alto (indirizzi alti, vicino a 0x7FFFFFFF) e cresce verso il basso (indirizzi più bassi), così può espandersi senza interferire subito con heap e codice. Utilizzato per variabili locali, return delle funzioni, frame di esecuzione.

==Heap==: Cresce dal basso verso l’alto (indirizzi crescenti). Usato per l’**allocazione dinamica** (Callo, Malloc, Calloc) ed è gestito dal processo e dal runtime, non cresce automaticamente come lo stack.

==Program Image==: Qui viene caricato l'eseguibile.

==Spazio Allocabile==: Zona intermedia che può essere usata per heap aggiuntivo o stack di altri thread.

==DDL==: Dynamic Link Library, DLL are the libraries for Windows. A library is a code module that contains. Functionality that is implemented by the operating system, or some support third-party package, which offers you programming capabilities

==TEB, PEB, shared user page==: Space for some page, which contain a number of features that the operating system places there.

```ad-example
title: Example on Stack
- Lo **stack cresce verso indirizzi bassi**.
    
- Se ho lo stack pointer (ESP) = `0x7FFD0000` e faccio una `push`, il valore viene scritto a `ESP - 4`.
    
- Perciò **aggiungere dati significa sottrarre all’indirizzo**.
    
- Se al contrario **aumento ESP (con add)**, sto “shrinkando” (riducendo) lo stac

```

>On Windows, any executable file, a binary, a program that you can run, It's called Portable Executable, PE.

>the stack grows to low addresses. I want more space, so up, I have to subtract from this value. And if I'm adding, this means that I'm shrinking the stack.

## MEMORY PROTECTION
**Paging** mechanisms 
- determine whether an address is valid 
- enforce read/write/execute permissions (granularity: regions) 
- pages in kernel memory are accessible only from kernel code 

Operating systems may enforce high-level security mechanisms to hinder memory vulnerability exploitation attacks 
- DEP (Data Execution Prevention) 
- ASLR (Address Space Layout Randomization) 
- Heap allocation randomization & other protections in Windows 10+

Memory is partitioned in chunks, each page as a site and within a page, the permission are fixed for the page. So a page and all the bytes in it can be readable, can be writable, can be executable, you can set it individually. But two bytes in the same page, they cannot have different permissions.
You use paging for, first of all, determining address validity, so to block all the cases where the program is trying to access memory that is either not valid. Then you can enforce security permissions.

On the hardware, we use it to differentiate what are the pages that only the kernel can read, and, I mean, to separate the 2GB for kernel and the 2GB for the users.

## BASIC X86 INSTRUCTIONS
Programs are made of three kinds of instructions:
- Data movement 
- Arithmetic & logic 
- Program flow control

Data movement instructions are straightforward:
 mov dest, src 
 Copy {register, memory content, immediate} to {register, memory location} 
 
 push src 
 pop dest 
 Used for stack manipulation (we will talk about them in a while…) 

## ARITHMETIC INSTRUCTIONS
These instructions are relevant for code analysis for many reasons 
- computing offsets and function addresses 
- stack pointer modification 
- used also for data movement or to update EFLAGS

![[MW9.png]]

## LOGIC INSTRUCTIONS
Common instances 
- zero-ing registers: xor eax, eax 
- extracting bits and checking conditions 
- obfuscation 
Beware that these operations are bit-wise. High-level logical operations such as && and || have a very different semantics.

![[MW10.png]]

## ROTATE/SHIFT INSTRUCTIONS
Frequently encountered in bit manipulations: (when src is absent, a default of 1 is assumed) 
![[MW11.png]]
## PROGRAM FLOW CONTROL
Control flow can be implemented in three ways:
- ==Unconditional branch==: EIP is replaced with some desired address 
- ==Conditional branch==: EIP is replaced with some desired address depending on the value of one or more bits from EFLAGS
- Function ==calls== and ==returns==: special type of unconditional branches.
Two primitives needed: 
- a way to specify the target of a branch (static or dynamic) 
- a way to evaluate a condition on the program state 
Code locations in assembly can be annotated with labels 
### UNCONDITIONAL BRANCHING
An unconditional branch can take as destination:
- an **offset**, specified as a relative offset from the current EIP value or as an absolute offset (from the base of the current code segment…) 
- or an **absolute address**, provided as a register or memory operand 

![[MW12.png]]
### CONDITIONAL BRANCHING
Conditional branches evaluate conditions over selected bits of the EFLAGS register. Common cases:
- **CF** (carry flag), meant for errors in unsigned arithmetics 
- **OF** (overflow flag), meant for errors in signed arithmetics 
- **SF** (sign flag), set when the result of an operation is negative 
- **ZF** (zero flag), set when the result of an operation is zero

We can use the cmp instruction to compare two values: cmp dest, src computes the difference dest-src without modifying dest, and sets the flags above in a way that enables many useful comparisons… 

- A jcc instruction checks the condition specified by cc suffix and jumps to the given offset accordingly (no absolute addresses) 
- Say we just executed cmp D, S:

![[MW13.png]]

Another common comparison instruction is test 
- it computes the bitwise AND of its operands without altering them 
- say we want to check whether register D holds zero as value: test D, D will set the zero flag iff. $D==0$, then **jz** can be used

But malware won’t use only cmp and test. Say, you can decrement a value with dec or sub and then check if the instruction set the zero flag with **jz** 🤧 (also optimizing compilers do that!)

```ad-bug
title: Prof è arrivato a slide 23!


```
