# The goal of malware analysis
Depp understanding on how malware works is crucial for:
1. **_Monitoring and attack prevention_**
	- identify recurring attack patterns
	- Build rules for monitoring and intrusion detection
	- Design IT systems that more resilient to forthcoming attacks

2. **_Incident response_**
	- Understand what exactly happened
	- Identify all compromised assets (machines, files, etc.)
	- Contain further expansion of the attack
	- Eradicate the attack
	- Recover efficiently

==Dissecting malware== to understand:
**_How it works_**
- Know your enemy’s strategies
**_How to identify it_**
- Extract signatures/IoCs (Indicators of compromise)
- Prevent further similar infections
**_How to defeat or eliminate it_**
- Rollback (if possible) its effects
- Clean the infected system


==NIST Incident Response Cycle==
![[MW14.png]]

# Signatures
**_Host-based signatures_**: Identify files/processes/registry keys on a victim computer that indicate an
infection.
**_Network signatures_**: Detect malware by analyzing network traffic (Does the malware inspect the surroundings? Does the malware contact an external Command & Control (C&C or C2) server?).  More effective when coupled with malware analysis. 
**_Behavioral signatures_**: Focus on what the malware does to the system, not the malware itself ( Behavioral analysis. Different from your standard antivirus signature!)

Se scopro la **_signature di un malware_** l'attaccante, per aggirare tale problema, potrebbe cambiare anche un solo bit non significativo che non altera le funzionalità chiave del malware, ricompilarlo e lanciarlo nuovamente. Questo, con alta probabilità, avrà una signature completamente diversa da quella trovata! Le signatures sono informazioni pratiche che utilizziamo per prevenire gli attacchi e che derivano dalle informazioni grezze che estraiamo come analisti di malware e che vengono chiamate indicatori di compromissione.

>Le signature sono utili ma molto fragili.

```ad-warning
Be conscious about the risks you are going to face:
You will be asked to dissect malicious software that is designed to harm computers (possibly your one).  You may need to run such malicious software in order to understand how it works.

Some of the code you’ll inspect have been designed by criminals.
Some IPs referenced in some malware may possibly be live. You must assume that behind that IP there is a criminal.

```

```ad-important
Stay safe:
- Keep a safe offline backup of your important data
- Always perform analysis on a virtual machine isolated from your main host
- Disconnect the virtual machine from the network unless netcomms are necessary
- If you find references to external IP addresses NEVER EVER try to directly
contact them

```

Now we need to understand how to identify these characteristics, which tools and methodologies we can use.
# Static Vs Dynamic Analysis
==Static Analysis==: Examine the malware without running it (never run it)
- **_Tools_**: strings, PE inspection tools, a disassembler like IDA Pro, etc...)

==Dynamic Analysis==: Run the malware and monitor its effects. Use a virtual machine and take snapshots.
- **_Tools_**: RegShot, Process Monitor, Process Hacker, CaptureBAT, debuggers,…
- RAM Analysis

>From dynamic analysis i can obtain sometimes partial information on the behaviour of the malware. But sometimes, i don't see nothing! So static analysis is also very important.

We have different kind of approaches:
# Basic Analysis
==Basic Static Analysis==: Observe the malware without looking at its code
- Tools: strings, PE inspection, etc... 
- Quick and easy but fails for advanced malware and can miss important behaviour.

We will not look at the code of the malware. We will just consider the malware as a sort of black box and we give it to several tools. These tools will provide us some information, and we will assume that information are correct!

==Basic Dynamic Analysis==:  Easy but requires a safe test environment but is not effective on all malware.

Means give the black box, our malware, to a tool. The tool will execute the malware, will observe automatically what the malware does during its functioning, and will return us with information.

```ad-important
Quando questi strumenti ci danno in output un report (100 pagine e più) bisogna saper leggere ed individuare quali sono le behavioural signatures. Bisogna essere in grado di capire cosa leggere di questo report ed estrarre da qui solo le informazioni rilevanti per costruire una behavioural signatures. Questo non è del tutto semplice!

```

# Advanced Analysis
==Advanced Static Analysis==: Reverse-engineering the malware code with a **_disassembler_**. Complex, requires understanding of assembly code and how such code interacts with the OS.

==Advanced Dynamic Analysis==:  Run code in a **_debugger_**. Examines internal state of a running malicious executable and how such state evolves.

> If we run it with a debugger, we don't only see the code, but we also see the impact of the code on the memory of the system, so we can inspect all the data that has been run through that code, and that makes a huge difference.
# Malware Analysis Process
![[MW15.png|400]]

# Expected Behaviors

==Persistence==
The malware installs itself in the system and it performs actions to guarantee its survivability to reboots, inspections and others... Often modifies the OS configuration and the changes are hidden.

==Uniqueness==
Malware is often incompatible with itself, multiple concurrent executions are meaningless or sometimes dangerous for the malware itself. (Think about two ransomware instances competing for the same resources). Checks at startup guarantee the execution of a single copy.

==Environment checks / Targeting==
Malware is designed to work in appropriate environment. Checks at startup if specific execution conditions are met:
- time/date
- Localization
- Availability
- Presence of specific resources 
- Presence of other processes

==Obfuscation and evasion==
Malware will try to hide its presence and its effects to stay undetected as long as possible.
It may inject code in other processes to conceal its real identity.
It may mangle its internal code to hide easily discoverable hints of its malicious nature.
It may leverage techniques to hamper the possibility to correctly analyse its behaviour.

==Fingerprinting & beaconing==
Malware will inspect the infected system and collect information about it.
Information can be used to “publicize” its presence to a remote server.

==Communication==
Malware often interacts with external command & control services to
- receive instructions and commands
- update its internal components
- exfiltrate data
Communication may use heterogeneous links types.
Data on channels is often obfuscated.

```ad-important
title: Important for the Exam

Don’t Get Caught in Details, You don’t need to understand 100% of the code, just focus on key features.
Try Several Tools:
- if one tool fails, try another one
- Don't get stuck on a hard issue, move along
```

>Bisogna approcciare il problema step by step. try to make some hypotheses, and then go a little deeper to try to confirm those hypotheses. You will immediately confirm some of them. And other hypotheses will need further investigation, okay? Avoid to go too deep inside the investigation of specific hypotheses, because possibly you will lose too much time on that.

# Basic Static Analysis
Techniques:
- Antivirus scanning
- Hashes
- A file’s strings, functions, and headers

# Antivirus Scanning
https://www.virustotal.com/gui/home/search
![[MW29.png|500]]

# Hashing samples
`MD5 or SHA-1`
Condenses a file of any size down to a fixed-length fingerprint, Uniquely identifies a file:
- There are MD5 collisions but they are not common
- Collision: two different files with the same hash
De-facto standard way of uniquely identifying samples.

Most operating systems provide md5 as a standard utility, If you use Windows you may prefer a GUI-wrapped version:
![[MW16.png]]

>Hash identify a specific file.
## Hash Uses
- **Etichettare un campione di malware:** l’hash funziona come un “codice identificativo” unico del file.
- **Condividerlo con altri analisti:** permette di riferirsi esattamente allo stesso file senza ambiguità.
- **Cercarlo online:** inserendo l’hash in database o servizi di sicurezza (es. VirusTotal) si può verificare se il file è già stato analizzato e classificato.

Invece di calcolare l’hash sull’intero file, lo si calcola sulla lista delle funzioni importate dalle librerie (API). Serve a raggruppare campioni simili in una stessa famiglia di malware. cambiando il packing, alcune costanti o l’aspetto binario, l’hash dell’intero file cambia, ma l’elenco di API spesso resta invariato. l’autore del malware può cambiare l’ordine, aggiungere import inutili o usare import dinamici (`LoadLibrary`/`GetProcAddress`) per alterare l’imphash.

```ad-danger
The ash is a fragile piece of information, because the attacker may easily produce a huge number of different samples with different ashes.

```
# Strings
Any sequence of printable characters is a string. String are terminated by a `null` value (`0x00`).
Ascii characters are $8$ bits long.

```ad-example
![[MW17.png]]

```

==Unicode== characters are $16$ bits long, Microsoft calls them "**_wide characters_**"

```ad-example
![[MW18.png]]

```

## The `strings` command
Il comando **`strings`** è disponibile su Linux/macOS e come utility separata su Windows (es. `Strings.exe` di Sysinternals). Estrae tutte le sequenze di caratteri leggibili (ASCII/Unicode) in un file binario, tipicamente usando una lunghezza minima (di default 4 su molte implementazioni, tu hai menzionato 3).
- Bold items can be ignored
- (1,2) GetLayout and SetLayout are Windows functions
- (3) GDI32.DLL is a Dynamic Link Library
- (4) looks like an IP address
-  (5) looks like an error msg 

![[MW19.png]]

# Obfuscation Through Packing
Il **packer** comprime o cifra il codice del programma (come uno zip). Dentro il file compresso le stringhe e le istruzioni diventano illeggibili, così l’analisi statica fallisce o è molto più difficile. Quando il programma viene eseguito, un piccolo **wrapper/loader** (il codice visibile) si occupa di decomprimere/decifrare il payload e poi lo lancia in memoria.

**Cosa si vede durante l’analisi statica**
- Molte stringhe mancanti o corrotte.
- Sezioni del PE con alta entropia (segno di compressione o cifratura).
- Un import table ridotto o anomalo (perché il loader fa quasi tutto dinamicamente).
- Il file “sembra piccolo” ma contiene codice che viene ricostruito a runtime.

**Rilevamento dei packer (es. PEiD / Detect It Easy)**
- Tool come **PEiD** o **Detect It Easy (DIE)** usano firme per riconoscere packer noti.
- **Attenzione:** alcuni plugin/strumenti possono lanciare il sample in modo automatico per identificare il packer (es. osservando il comportamento di unpacking).  
    → **Perciò è fondamentale** usare una macchina virtuale isolata, senza rete e con snapshot pronti, oppure preferire metodi puramente statici

![[MW20.png]]

# File execution in Windows
What happen when you double click an executable file in Windows? The OS (actually the **loader**) looks in the file to understand what to do. What’s in the file?
- Code
- Data
- Other Resources
- Metadata

>All these information need to be organized to be correctly interpreted by the loader.

## The Portable Execution File Format

```ad-abstract
title: Definition
Il **PE** è il formato usato da Windows per eseguibili e librerie (`.exe` e `.dll`).  
Contiene tutte le informazioni necessarie al sistema operativo per **caricare ed eseguire** il programma. Praticamente ogni file eseguibile su Windows è in formato PE.

```
### Struttura di base
1. **MS-DOS Header + Stub** → parte iniziale, serve per compatibilità con vecchi sistemi DOS.
2. **PE Header** → metadati fondamentali (info sul tipo di file, punti di ingresso, librerie usate, ecc.).
3. **Section Table** → “indice” che descrive le varie sezioni del file.
4. **Sezioni** → parti del file dove è diviso il contenuto (codice, dati, risorse, ecc.).

![[MW21.png]]

PE files usually contain at least **_two sections_**. Sections that are most commonly present include:
- **_Executable Code Section_**: Named .text (Microsoft) or CODE (Borland).
- **_Data Sections: Named_** .data, .rdata, or .bss (Microsoft) or DATA (Borland).
- **_Resources Section_**: Named .rsrc.
- **_Export Data Section_**: Named .edata.
- **_Import Data Section_**: Named .idata.
- **_Debug Information Section_**: Named .debug.

The names of the sections are actually irrelevant as they are ignored by the OS; they are present only for programmer convenience. Consequently, very different names may be found, as packers often use their own names.
## DOS HEADER + STUB
The DOS header occupies the first $64$ bytes of the PE file. Its presence allows DOS to recognize the file as a valid executable and run the DOS stub. The DOS stub usually prints the string: "This program must be run under Microsoft Windows".

- The DOS "magic" signature is 5A4Dh ("M Z").
- The field `e_lfanew` (at offset 0x3C) points to the PE Header.

![[MW22.png]]
![[MW23.png]]

## PE HEADER
The ==PE Header== begins with a Signature whose value is always $50450000h$ ("PE"), taking up $4$ bytes. The header is composed of three main parts:

1. **_COFF FileHeader_** (20 bytes): 
	- Contains the NumberOfSections field.
	- Contains the TimeDateStamp, which shows when the executable was compiled. This date can sometimes be wrong or faked (e.g., all Delphi programs may show June 19, 1992).
	- Contains Characteristics flags which dictate whether the PE file is an executable or a DLL.

2. **_OptionalHeader (224 bytes)_**: This section contains Standard COFF fields and Windows-Specific fields. Key fields include:  
	- AddressOfEntryPoint (RVA): The Relative Virtual Address (RVA) of the first instruction to be executed.
    - ImageBase: The preferred load address for the file in memory. In 99% of cases, this is 400000h.
	- SectionAlignment: The granularity of section alignment in memory. If the value is 4096 (1000h), each section must start at a multiple of 4096 bytes.
	- FileAlignment: The granularity of section alignment in the file on disk. If the value is 512 (200h), each section must start at a multiple of 512 bytes.
	- SizeOfImage: The overall size of the PE image in memory. It is the sum of all headers and sections aligned to SectionAlignment.
	- SizeOfHeaders: The size of all headers plus the section table. This value can also be used as the file offset of the first section in the PE file.
	- Data Directories (128 bytes): Structures pointing to critical information such as the Export Table and Import Table.

![[MW24.png]]

## PE HEADER - SIGNATURE + FILE HEADER
![[MW25.png]]
## PE HEADER - OPTIONAL HEADERS
![[MW26.png]]![[MW27.png]]

## PE HEADER - SECTION TABLE
The Section Table follows the Optional Header. It consists of one 40-byte record for each section defined in the file.

Key fields in each Section Table Record:
- **_Name_**: Section name.
- **_Virtual Size_**: Size of the section once loaded in memory (how much space the loader will allocate for it).
- **_Virtual Address (RVA)_**: RVA of the section.
- **_Size of Raw Data_**: The size of the section's data in the file on disk.
- **_Pointer To Raw Data_**: Offset from the file's beginning to the section's data.
- **_Characteristics_**: Flags indicating properties, such as whether the section contains executable code, initialized/uninitialized data, and whether it can be written to or read from.

After the section headers we find the sections themselves.
- **_On Disk_**: Each section starts at an offset that is a multiple of the FileAlignment value. There will be 00 byte padding between each section’s data.
- **_In RAM_**: When loaded into RAM, sections always start on a page boundary. This alignment value is stored in SectionAlignment. On x86 CPUs, pages are 4kB aligned; on IA-64, they are 8kB aligned.

# LOADING IN MEMORY 
![[MW28.png]]
The PE header lists libraries and functions that will be loaded. Their names can reveal what the program does (e.g., URLDownloadToFile indicates a program downloads something).

# Imports and Exports
Whenever you're requesting something from the operating system, You should import it.

Imports are functions used by a program that are stored in a different program, such as a library.
- DLLs export functions.
- EXEs import functions.
- Both imports and exports are listed in the PE header. Exports should be rare in EXEs.

## Clues (indizi) in libraries
- The PE header lists libraries and functions that will be loaded 
- Their names can reveal what the program does 
- e.g. URLDownloadToFile indicates that the program downloads something 

## Linking Methods
Programs connect to libraries via three methods:
1. ==Static Linking==: Rarely used for Windows executables (more common in Unix/Linux). All code from the library is copied into the executable, making it large in size but self-contained.
2. ==Dynamic Linking==: The most common method. The Host OS searches for the necessary libraries when the program is loaded. (le dipendenze (DLL) sono dichiarate nell’Import Table del PE e il loader risolve gli indirizzi all’avvio.)
3. ==Runtime Linking==: Unpopular in friendly programs, but common in malware (especially packed or obfuscated). It is also used by software that allows dynamic loading of plugins. Connection to libraries happens only when needed, not when the program starts. This is most commonly done using the `LoadLibrary` and `GetProcAddress` functions.

## Tools and Examples
- **_Dependency Walker_**: Shows dynamically linked functions. Normal programs have many DLLs, but malware often shows very few due to runtime linking.
- **_Keylogger_**: A typical keylogger imports User32.dll and uses the function SetWindowsHookEx, a popular way for keyloggers to receive keyboard inputs. It might export functions like LowLevelKeyboardProc or LowLevelMouseProc to send the data elsewhere, and use RegisterHotKey to define a special keystroke (like Ctrl+Shift+P) to harvest the collected data.
- **_A Packed Program_**: Will show very few functions, as all that is visible is the unpacker.
- **_Resource Hacker_**: A tool that allows analysts to browse the .rsrc section for strings, icons, and menus.