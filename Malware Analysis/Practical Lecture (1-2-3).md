>In this course we will use the Intel syntax
# X86, x64

==**x86 (32 bit)**==
- **Architettura storica** dei processori Intel/AMD
- **Limite RAM**: massimo 4 GB (in pratica ~3.25 GB)
- **Solo software 32-bit**
- **Ormai obsoleto** per uso moderno
- Utilizza lo stack per passare parametri con registri a 32 bit (`12345678h`)
==**x64 (64 bit)**==
- **Evoluzione** di x86 (chiamato anche x86-64)
- **RAM praticamente illimitata** (128+ GB su sistemi consumer)
- **Esegue sia software 64-bit che 32-bit**
- **Standard attuale** per tutti i PC moderni
- usa principalmente i registri (RCX, RDX, R8, R9) a 64 bit

## Differenze Chiave

|Aspetto|x86|x64|
|---|---|---|
|**RAM**|Max 4 GB|Teoricamente 16+ TB|
|**Software**|Solo 32-bit|64-bit + retrocompatibile 32-bit|
|**Prestazioni**|Limitate|Superiori|
|**Sicurezza**|Base|Protezioni avanzate|

## Perché x64 è meglio
- ✅ **Più RAM** per multitasking e applicazioni pesanti
- ✅ **Compatibilità completa** con software nuovo e vecchio
- ✅ **Prestazioni migliori** soprattutto in gaming e produzione
- ✅ **Più sicuro** con protezioni hardware integrate

**Oggi x64 è la scelta obbligata** per qualsiasi computer moderno.

# x86
```ad-abstract
title: Definition
**x86 è un'architettura di istruzioni per processori (CPU)** a 32 bit

```


Reverse engineering of binary code is difficult. 
Thankfully, only some portions of a malware sample really require it 
==FACT==: malicious code $\not =$ compiler-generated code 
- hand-written sequences 
- self-modifying code 
- subtle semantics (e.g., jump in the middle of an instruction) 
- obfuscation of control and data flows 
- other decoys

## DECOMPILATION?
Decompilers (e.g., Ghidra, Hex-Rays) try to reconstruct a high-level C-like representation of a binary code fragment.
**Process far from perfect**
- information loss during compilation (e.g., types, identifiers) 
- decompiling obfuscated code returns an obfuscated source 
- anti-analysis techniques 
- Nevertheless, helpful for reverse-engineering professionals

## CPU and Memory Basics
![[MW4.png]]
RAX, RBX, RCX, RDX: Those are the registers where normally you put your data to have the CPU work on this data. (==x64==)
## ISA AND X86
```ad-abstract
title: Instruction Set Register
L’**ISA** (Instruction Set Architecture) è il **modello astratto** che descrive **come un processore può essere programmato**.  
In pratica, è **il linguaggio della CPU**: definisce **quali istruzioni** la CPU è in grado di capire ed eseguire (ad esempio: sommare, spostare dati, confrontare valori, saltare a un’altra istruzione, ecc.).
```

L’ISA rappresenta **l’interfaccia tra software e hardware**:

| Lato software                                                                                        | ↔   | Lato hardware                                                  |
| ---------------------------------------------------------------------------------------------------- | --- | -------------------------------------------------------------- |
| Programmi scritti da esseri umani o compilatori (in linguaggio assembly o linguaggi di alto livello) |     | Elettronica del processore (ALU, registri, memoria, bus, ecc.) |
| Usa istruzioni definite dall’ISA                                                                     |     | Implementa fisicamente le operazioni richieste dall’ISA        |
- **Il programmatore o il compilatore** scrive del codice che **segue le regole dell’ISA** (cioè usa le istruzioni definite in essa).  
    → Esempio: `ADD R1, R2, R3` (somma il contenuto di R2 e R3 e salva in R1).
- **L’assembler** traduce questo codice assembly in **codice binario** (una sequenza di 0 e 1) che la CPU può interpretare.  
    → Ogni istruzione ha un suo **opcode** binario definito nell’ISA.
- **L’hardware** (cioè la microarchitettura del processore) **esegue** quelle istruzioni binarie.


Intel defined the x86 ISA for its 8086 processor (1976–1978); later extensions preserved backward compatibility. The 32-bit version, also known as IA-32, remains widely used today—most malware still targets it—while x86-64 (or x64) is its 64-bit successor.

## WORD SIZE AND ENDIANNESS
Una **word** è l’**unità naturale di dati** per una specifica architettura di CPU, cioè la quantità di bit che il processore elabora in un’unica operazione.

- Negli **x86 a 32 bit**, una word è di **32 bit** (4 byte).

Tuttavia, per **motivi di compatibilità** con i vecchi processori a 16 bit (come l’8086), nelle istruzioni x86:
- una **word** è considerata **16 bit**,
- una **dword** (_double word_) è **32 bit**.

👉 Quindi, anche se l’architettura moderna è a 32 bit, il linguaggio assembly x86 continua a usare la vecchia terminologia.
![[MW5.png]]

>In the first, the most important word is "AB".

```ad-info
Sia **Intel** che **AMD** (e praticamente tutti i processori x86/x64) utilizzano **Little Endian**.

```


==word== us `16-bit`,to refers to `32` we have to say "==double word==", to refers to `64` we have to say a "==quad-word==". The concept of word is 32'bit then in assembly there is the subtle difference.

## Registers
Coders use many variables in their code.
CPU work on a limited number of registers.

```ad-abstract
title: Register Definition
A ==register== is an internal small piece of area inside the cpu, extremely fast where temporaly are stored data or addresses during the instructions execution.

```

- **_General-purpose registers_**: can store data or memory addresses, These are the ones used most often by programs. Are 32-bit long (`EAX`, `EBX`, `ECX`, `EDX`, `ESI`, `EDI`, `EBP`, `ESP`)
- **_Status Register_**: Contains information about the processor state after the last instruction executed. It is used in the conditional instruction (`if`, `cmp`, `jz`, `jnz`)
- **_Program Counter_**: Stores the address of the next instruction to be executed. Its value is automatically updated after each instruction.
- **_Other registers_**: There are also control, segmentation, debug, etc. registers, used for processor-specific purposes.

**Accessing Registers**
![[MW6.png]]

If i want the entire register i should call it by this name for entirely: EAX (E stands for extended, because initially taking the entire register, which was 16-bit, meant taking the entire contents, i.e. AX. The E stands for extension and allows you to also take the other 16 additional bits).

```ad-important
==Status== and ==program counter== registers, there is no way to modify them directly!

```

>$H$ stay for higher and $L$ stay for lower

>Registers are 32-bit

## Instruction Cycle
Instruction cycle describe how the CPU execute every single instruction:

1. **_Fetch_**
	- The CPU reads from memory the instruction located at the address contained in the **EIP** (_Instruction Pointer_, called **RIP** in 64-bit systems).
	- EIP always indicates **the next instruction to execute**.
2. Decode
	- The Control Unit interprets the instruction: it separates the opcode (type of operation) from the operands (the data to be acted upon).
3. Execute
	- The instruction is executed, for example, by the ALU (for arithmetic operations) or by data movements between registers and memory.
	- Upon completion, the EIP advances to the next instruction, unless the current instruction changes the flow of control (such as `jmp`, `call`, or `ret`).


```ad-example
> “The letters A, P, P, L, E, that’s an instruction...”

Immagina la memoria come un libro scritto in **byte** (sequenze di 8 bit).

- Se la CPU legge i primi 5 byte `41 50 50 4C 45` (che corrispondono in ASCII ad “APPLE”), quello è il **fetch**.
    
- Poi la CPU **decode**: riconosce che quei byte hanno un significato come istruzione.
    
- Infine **execute**: compie l’azione richiesta da quell’istruzione.
    

Quindi la CPU non vede lettere o parole, ma **sequenze di byte** che hanno senso solo secondo il set di istruzioni (ISA, Instruction Set Architecture).

```

 Instructions vary in size (1-15 bytes) and are stored consecutively in memory along with any immediate operands (i.e., data or addresses) they might use. Register operands are embedded instead in the opcode binary representation:
 
```bash
b8 01 00 00 00 mov eax, 0x1 
bf 01 00 00 00 mov edi, 0x1 --littleendian
```

`b8` è l’**opcode** (==operation code==) che significa “muovi un valore immediato dentro `eax`”.
I 4 byte successivi `01 00 00 00` rappresentano il numero **0x1** in **little-endian** (cioè byte meno significativo per primo).
Quindi tutta l’istruzione occupa 5 byte. Allo stesso modo:
`bf` è l’opcode che significa “muovi un valore immediato dentro `edi`”.
Segue il valore immediato `01 00 00 00`.

# Memory Addressing
Addressing modes provide a way to express the addresses of data to be read from/written to the main memory.
Expressions can take immediate operands, registers, or both.
Addressing modes enable operand combinations to compute complex expressions that depend on the program state.
Usually, an instruction can have at most one memory operand.

>We cannot have the same operation that read and write in the same time.

## Common Addressing Modes
Some popular ways to specify data to be read from/written to the main memory. For the last two rows, the offset field is optional.

| Mode                      | Intel Syntax             |
| ------------------------- | ------------------------ |
| Immediate                 | Mov eax, $[0x1000]$      |
| Register                  | mov eax,$[esi]$          |
| Register + Offset         | mov eax,$[esp-8]$        |
| Register*width + Offset   | mov eax, $[ebx*4+0xff]$  |
| Base + Reg*width + Offset | mov eax, $[edx+ebx*4+8]$ |


```ad-example

In the first line of the table, we are moving into the register A what is written in memory at address $[0x1000]$.
```

## INTEL VS. AT&T SYNTAX
x86 assembly has two main syntax types: `AT&T` and `Intel`. Intel syntax is dominant in the Windows world. Relevant differences:

![[MW7.png|400]]

## Memory map of a Process
It illustre how a windows process for a program is orchestrated!

Quando lanci un programma su Windows, il sistema operativo crea un **processo** e gli assegna uno **spazio di indirizzamento virtuale**.  
In architettura a 32 bit, questo spazio è di **4 GB (2³² indirizzi)**. Windows lo divide in:
- **2 GB inferiori (0x00000000 – 0x7FFFFFFF): spazio utente**
- **2 GB superiori (0x80000000 – 0xFFFFFFFF): spazio kernel** (non mostrato nell’immagine).
Quello che vedi è una **mappa semplificata** della metà “user space”.

![[MW8.png]]

><mark style="background: #CACFD9A6;">Grey</mark> area are inaccessibile areas!

==Stack==: Parte dall’alto (indirizzi alti, vicino a 0x7FFFFFFF) e cresce verso il basso (indirizzi più bassi), così può espandersi senza interferire subito con heap e codice. Utilizzato per variabili locali, return delle funzioni, frame di esecuzione.

==Heap==: Cresce dal basso verso l’alto (indirizzi crescenti). Usato per l’**allocazione dinamica** (Callo, Malloc, Calloc) ed è gestito dal processo e dal runtime, non cresce automaticamente come lo stack.

==Program Image==: Qui viene caricato l'eseguibile.

==Spazio Allocabile==: Zona intermedia che può essere usata per heap aggiuntivo o stack di altri thread.

==DDL==: DLLs are libraries for Windows, that is, code modules that contain functionality already implemented by the operating system or third-party support packages, providing the programmer with additional capabilities without having to rewrite the code.

==TEB, PEB, shared user page==: Space for some page, which contain a number of features that the operating system places there.

```ad-example
title: Example on Stack
- Lo **stack cresce verso indirizzi bassi**.
    
- Se ho lo stack pointer (ESP) = `0x7FFD0000` e faccio una `push`, il valore viene scritto a `ESP - 4`.
    
- Perciò **aggiungere dati significa sottrarre all’indirizzo**.
    
- Se al contrario **aumento ESP (con add)**, sto “shrinkando” (riducendo) lo stac

```

```ad-important

On Windows, any executable file, a binary, a program that you can run, It's called ==Portable Executable==, PE.
```


The stack grows to low addresses with `sub`/`push` operation. 
If I'm adding, this means that I'm shrinking the stack with `add`/`pop` operation.

| Azione                 | Istruzione   | Effetto su ESP | Stack                                |
| ---------------------- | ------------ | -------------- | ------------------------------------ |
| Allocare spazio / push | `sub esp, n` | ESP diminuisce | Stack cresce verso indirizzi bassi   |
| Liberare spazio / pop  | `add esp, n` | ESP aumenta    | Stack si riduce verso indirizzi alti |

```ad-important
Differenza di rappresentazione tra Stack e Memoria RAM!
![[Schema_Stack.jpg|500]]
```

## Memory Protection
The paging system divides RAM memory into pages, which are memory protection and management units. Each page has fixed read, write, and execute permissions, valid for all bytes of the page:

>You cannot have different permissions on two bytes of the same page.

>Le pagine della **memoria del kernel** sono accessibili **solo dal codice kernel**.

==Main Paging Function==
**Validità degli indirizzi**    
    - Blocca i programmi che cercano di accedere a indirizzi **non validi**.
**Controllo dei permessi**
    - Ogni pagina può essere marcata come **readable, writable, executable**.
    - Permette di proteggere il kernel e altre aree sensibili.

I sistemi moderni aggiungono misure di sicurezza per ridurre il rischio di exploit della memoria:
- **DEP (Data Execution Prevention)** → impedisce l’esecuzione di codice in aree dati.
- **ASLR (Address Space Layout Randomization)** → randomizza gli indirizzi di stack, heap e librerie.
- **Heap allocation randomization** e altre protezioni (es. Windows 10+).

## Basic X86 instructions
Programs are made of three kinds of instructions:
- Data movement 
- Arithmetic & logic 
- Program flow control

### Data Movement
**Data movement** instructions are used to **move values ​​between registers, memory, and immediates**.

```
mov eax, ebx       ; copia il contenuto di EBX in EAX
mov eax, [var]     ; copia il contenuto della variabile in EAX
mov [var], eax     ; copia il contenuto di EAX nella variabile
mov eax, 0x1       ; carica il valore immediato 1 in EAX

```
 
### ARITHMETIC INSTRUCTIONS
These instructions are relevant for code analysis for many reasons 
- computing offsets and function addresses 
- stack pointer modification 
- used also for data movement or to update EFLAGS

![[MW9.png]]

## Logic Instructions
Common instances 
- zero-ing registers: xor eax, eax 
- extracting bits and checking conditions 
- obfuscation 
Beware that these operations are bit-wise. High-level logical operations such as && and || have a very different semantics.

![[MW10.png]]

## Rotate/Shift Intruction
Frequently encountered in bit manipulations: (when src is absent, a default of 1 is assumed) 
![[MW11.png]]
## Program Flow Control
Control flow can be implemented in three ways:
- ==Unconditional branch==
	- EIP (Extended Instruction Pointer) is replaced with some desired address.  
	- Always executed without condition (`jmp`, `call`)
- ==Conditional branch==: 
	- **Sostituisce EIP/RIP** solo se condizioni sono soddisfatte
	- **Basato sui flag** in EFLAGS/RFLAGS

```C
cmp eax, ebx
je  equal_label     ; Salta solo se ZF=1 (eax == ebx)
```

>Function ==calls== and ==returns==: special type of unconditional branches.


Per implementare il controllo di flusso sono necessari due elementi fondamentali:
- **Un metodo per specificare la destinazione** di un salto (statica o dinamica)
- **Un metodo per valutare una condizione** sullo stato del programma

### Unconditional Branching
An unconditional branch can take as destination:
- an **offset**, specified as a relative offset from the current EIP value or as an absolute offset (from the base of the current code segment…) 
- or an **absolute address**, provided as a register or memory operand 

![[MW12.png]]

### Conditional Branching
Le ==istruzioni di salto condizionale== (`jcc: jump if condition code`) permettono al programma di **cambiare il flusso di esecuzione** a seconda di una condizione.
Queste condizioni si basano sui **flag del registro EFLAGS** che riflettono lo stato dell’ultima operazione aritmetica:

| Flag                   | Significato | Quando si setta                  |
| ---------------------- | ----------- | -------------------------------- |
| **CF (Carry Flag)**    | Riporto     | Errori in aritmetica senza segno |
| **OF (Overflow Flag)** | Overflow    | Errori in aritmetica con segno   |
| **SF (Sign Flag)**     | Segno       | Risultato negativo               |
| **ZF (Zero Flag)**     | Zero        | Risultato = 0                    |

We can use the `cmp` instruction to compare two values: 
`cmp dest, src ` $\to$ computes the **difference** dest-src without modifying dest, and **sets the flags** above in a way that enables many useful comparisons… 

**`jcc`** Controlla **solo i flag necessari** per quella specifica condizione.
	`je`/`jz` guarda **ZF**
	`jg`/`jnle` guarda **SF, OF e ZF**
	`ja`/`jnbe` guarda **CF e ZF**
Se la condizione è vera, fa **un salto relativo** all’offset specificato; altrimenti continua con l’istruzione successiva.

![[MW13.png]]

Another common comparison instruction is `test` 
- it computes the bitwise AND of its operands without altering them 
- say we want to check whether register D holds zero as value: test D, D will set the zero flag (`ZF`). $D==0$, then **jz** can be used

But malware won’t use only `cmp` and `test`. Say, you can decrement a value with dec or sub and then check if the instruction set the zero flag with **jz** 🤧 (also optimizing compilers do that!)

## Function and Stack Frames
```ad-abstract
title: Definition of Function
Unit of code that controls register values and its portion of stack independently of other units
- se un'unità di codice ne chiama un'altra, quest'ultima non dovrebbe sovraccaricare i registri in uso.
- Le CPU sono dotate di pochi registri di uso generale: è possibile riversare (ovvero salvare) alcuni valori sullo stack e recuperarli in seguito durante l'esecuzione, se necessario.


```

>Every function have a specific stack.

### Importanza del Return Address
The ==return address== is crucial: without it, the program wouldn't know where to resume execution after the end of a function.
- When a function is called, the address of the instruction following the call is saved on the stack.
- At the end of the function, the `ret` instruction retrieves this address and execution continues from the correct point.

### Stack and Stack Frames
```ad-abstract
title: Definition of Stack
lo **stack** è una porzione di memoria condivisa da tutte le funzioni di un programma, ma ogni funzione attiva ha il proprio **stack frame** dedicato. Questi frame vengono creati dinamicamente durante l'esecuzione del programma per gestire le chiamate alle funzioni.

```

```ad-abstract
title: Definition of Stack Frame
Uno **stack frame** è una struttura di dati che contiene tutte le informazioni necessarie per gestire una singola chiamata a funzione. Ogni volta che una funzione viene chiamata, viene creato un nuovo stack frame nello stack. Quando la funzione termina, il suo frame viene rimosso.

```

Uno stack Frame tipicamente contiene:
- gli **argomenti** passati alla funzione,
- le **variabili locali** e altri dati temporanei,
- l’**indirizzo di ritorno** (return address), ovvero il punto del programma in cui riprendere l’esecuzione dopo l’uscita dalla funzione.
- **Salvataggio dei registri**: alcuni registri, come il frame pointer (EBP), possono essere salvati per preservare lo stato precedente della funzione chiamante.

```ad-attention
title: Gerarchia!
- Ogni thread ha il suo stack dedicato
- Ogni stack, di un tread, è suddiviso in tanti stack frame, uno per ogni funzione
- Questi frame vengono creati dinamicamente durante l'esecuzione del programma per gestire le chiamate alle funzioni.

```

```ad-danger
title: Gestione dei registri
Le CPU dispongono di un numero molto limitato di registri generali.

```

Quando una funzione (es. **A**) chiama un’altra funzione (es. **B**), quest’ultima non può sapere quali registri siano già in uso da **A**.

```ad-success
title: Goal

Per evitare conflitti, vengono stabilite delle ==calling conventions==: regole che definiscono quali registri devono essere preservati e quali possono essere liberamente usati.
Poiché i registri non sono mai sufficienti per tutte le variabili, alcune devono essere salvate sullo stack e ricaricate quando necessario.
```

### Stack Pointer
Il **puntatore allo stack (SP)** è un registro speciale che indica la cima dello stack.
- Nei processori x86 a 32 bit, lo SP si chiama **ESP (Extended Stack Pointer)** 
In teoria è un registro generale, ma in pratica non deve essere modificato arbitrariamente, dato che serve a mantenere l’ordine corretto delle allocazioni temporanee e a gestire i frame delle funzioni.

## Locale Storage
Suppose we don’t have free registers left and we would like to add to EDX the difference between EBX and ECX:

![[MW30.png]]

## PUSH AND POP INSTRUCTIONS
- `push src` moves the top of the stack up by 4 bytes, then copies the content of the operand (immediate or register) to the address pointed by the updated ESP 
- `pop dest` copies the 4 bytes currently pointed by ESP to the dest register, then moves the top of the stack down by 4 bytes 
- ==push/pop operations== can also be realized via sub/add + mov:

![[MW31.png]]

```ad-missing
title: Problem
Quando una funzione esegue delle operazioni sullo **stack** (ad esempio `push` di valori o allocazione di variabili locali), il **Stack Pointer (SP)** si sposta di conseguenza.

- Ogni `push` decrementa lo stack pointer (dato che lo stack cresce verso il basso in memoria).
    
- Ogni `pop` lo incrementa.
    

Il problema è che, se durante l’esecuzione di una funzione fai molte operazioni di `push` e `pop`, diventa difficile **tenere traccia della posizione originale dello stack**.

```

```ad-success
title: Solution
Per risolvere questo, si introduce un altro registro: il ==Base Pointer (BP)==, spesso chiamato anche **Frame Pointer (FP)**.
- Registro `EBP`
  
  
**_Meccanismo tipico_**:

1. **Entrata nella funzione**:
    
    - Salvo il valore corrente del base pointer sullo stack (`push ebp` in x86).
        
    - Copio lo stack pointer dentro il base pointer (`mov ebp, esp`).  
        → In questo modo, **EBP** diventa un “punto di riferimento stabile” per l’intera funzione.
        
2. **Durante la funzione**:
    
    - Posso spostare lo stack pointer (`esp`) per allocare spazio a variabili locali.
        
    - Posso fare `push` e `pop` liberamente.
        
    - Ma i riferimenti agli **argomenti** e alle **variabili locali** li faccio sempre rispetto al **base pointer**, che resta fisso.
        
        - Esempio: `[ebp+8]` → primo argomento della funzione
            
        - `[ebp-4]` → variabile locale
            
3. **Uscita dalla funzione**:
    
    - Ripristino lo stack pointer riportandolo al valore di **ebp**.
        
    - Recupero il vecchio valore di **ebp** dallo stack (`pop ebp`).
        
    - Infine eseguo `ret`, che usa il return address salvato.

```

## Using The Base Pointer
When entering a function that makes use of local variables, **register EBP** can be used to reference their locations via **fixed offsets**:

```assembly
mov ebp, esp        ; salva il valore dello stack pointer in ebp
sub esp, 8          ; riserva 8 byte sullo stack (due variabili locali 4 ciascuna)
mov [ebp-8], 0x1111 ; salva 0x1111 nella variabile locale a offset -8
mov [ebp-4], 0xabadcafe ; salva 0xabadcafe nella variabile locale a offset -4
...
mov eax, [ebp-8]    ; carica 0x1111 in eax

```

![[MW32.png]]

**_Schema a sinistra (prima dell’allocazione)_**
- `esp` punta all’ultima cella occupata (0x3424).
- Non ci sono ancora variabili locali allocate.

**_Schema a destra (dopo l’allocazione e scrittura)_**
- `esp` è sceso di 8 per creare spazio.
- Negli slot allocati troviamo:
    - `[ebp-8] = 0x1111`
    - `[ebp-4] = 0xabadcafe`
- `ebp` resta fisso, a indicare il “punto d’ingresso” della funzione.
- `esp` invece continua a muoversi se faccio `push` o `pop`.


```ad-info
title: To understand better...

Se usassi solo `esp` per accedere alle variabili, ogni `push`/`pop` cambierebbe la loro posizione → diventa impossibile seguirle.  # La bella confusione
Con `ebp`, invece, ho un **riferimento stabile**: le variabili locali hanno sempre lo stesso offset da `ebp`
```

## CALL AND RET INSTRUCTIONS

### Funzionamento di `CALL`
- L’istruzione **`call`** serve per invocare una funzione.
- Diversamente da un semplice **`jmp`**, prima di trasferire il controllo:
    1. **Salva sullo stack** l’indirizzo dell’istruzione successiva alla `call`.  
        → Questo indirizzo si chiama **return address**.
    2. Salta all’indirizzo della funzione chiamata (callee).

>In questo modo, al termine della funzione, il programma sa esattamente dove riprendere l’esecuzione.

1. Funziona $A$ in esecuzione
```
Stack (cima in alto, indirizzi decrescenti)
+-----------------------+
| variabili locali di A  |
+-----------------------+

```

2. `call B` → salva indirizzo di ritorno
	- L’istruzione `call B` fa:
		- Salva **return address** nello stack (punto dove riprendere in A dopo B)
		- Salta all’indirizzo di B

```
Stack
+-----------------------+
| return address (A+1)  |  <-- SP punta qui
+-----------------------+
| variabili locali di A  |
+-----------------------+
```

3. Quando entri in B, viene creato un **nuovo frame** per variabili locali di B
```
Stack
+-----------------------+
| variabili locali di B  |  <-- SP punta qui (cima del frame di B)
+-----------------------+
| return address (A+1)  |
+-----------------------+
| variabili locali di A  |
+-----------------------+

```

4. Passo 4: Fine funzione B (`ret`)
```
Stack
+-----------------------+
| variabili locali di A  |  <-- SP punta qui (frame di A)
+-----------------------+

```


```ad-example
![[MW33.png]]

```


### Funzionamento di `RET`
- L’istruzione **`ret`** viene usata dalla funzione chiamata per **tornare al chiamante (caller)**.
- `ret` preleva dallo stack il **return address** precedentemente salvato da `call`.
- Carica questo indirizzo in **EIP** (Instruction Pointer), così l’esecuzione riprende dal punto corretto.

Il `Return Address` permette di rientrare esattamente dopo la chiamata. Se questo valore viene **corrotto o modificato** (ad esempio in un attacco di buffer overflow), l’esecuzione può essere deviata verso codice arbitrario.

```ad-important

Le funzioni esistono solo come astrazione logica, nel codice macchina non ci sono separatori netti che le distinguono. In memoria il codice è un flusso continuo di istruzioni.
```


## Rules Part: Calling Conventions
(At least) two questions left to answer: 
- How are register values preserved across function invocations? 
- How are parameters being passed to functions? 

**_Calling conventions regulate_**
- how parameters are passed (via registers/stack) and in which order 
- which registers the callee must preserve for the caller 
- who performs ESP realignment upon return 

Malware may use custom calling conventions for its functions, but has to follow standard ones to interact with Windows APIs 

```ad-info
title: Appunti miei

For passing arguments we need the stack. The calling convention is also gonna say, who's gonna update the stack pointer to say that these arguments that they passed are no longer needed. we have huge difference between Linux and windows. Malwares can have their custom calling convention.
```
## Windows Conventions
**Convenzioni di chiamata (calling conventions) in Windows**, cioè di regole su come le funzioni ricevono argomenti, restituiscono valori e gestiscono il registro e lo stack.

Different conventions can be used in the same program 
### 1. `cdecl` (C programs)
**Caratteristiche principali:**
1. **Argomenti passati nello stack, da destra verso sinistra**
    - Se la tua funzione è, ad esempio, `func(a, b, c)`, allora nello stack l’ordine sarà: `c`, `b`, `a`
    - Quindi il **primo argomento `a` sarà l’ultimo a essere scritto nello stack**.
2. **Registri caller/callee-save**
    - **Caller-save**: il chiamante deve salvare `EAX`, `ECX` ed `EDX` se vuole usarli dopo la chiamata.
        - Questo significa che il callee (la funzione chiamata) può usare liberamente questi registri senza preoccuparsi di ripristinarli.
    - **Callee-save**: la funzione chiamata deve salvare (`push`) e ripristinare (`pop`) `EBP`, `EBX`, `EDI` ed `ESI` se li usa.
3. **Stack cleanup**
    - **Il chiamante (caller) ripulisce lo stack** dopo il ritorno dalla funzione.
    - Esempio: se la funzione prende 3 argomenti (ognuno 4 byte), dopo il `ret` il caller farà `add esp, 12` per riportare lo stack alla posizione corretta.
4. **Valore di ritorno**
    - Valore a 32-bit restituito in `EAX`.

### `stdcall` (Win32 API)
**Caratteristiche principali:**
1. **Argomenti e registri**
    - Stesso ordine di `cdecl`: argomenti pushati da destra a sinistra, e stessa regola dei registri caller/callee-save.
2. **Stack cleanup**
    - **Il callee (la funzione chiamata) ripulisce lo stack** prima di ritornare.
    - Questo viene fatto tramite l’istruzione `ret N`, dove `N` è il numero di byte da rimuovere dallo stack (tipicamente `N = numero_argomenti × 4`).
    - Dopo l’aggiornamento di `EIP` con l’indirizzo di ritorno, lo stack viene sistemato automaticamente.

```ad-info
Functions can follow different conventions (linux or windows).

```

```ad-important
![[MW38.png]]

```


```ad-example
title: Example CDECL
==cdecl==
![[MW34.png]]
==Stdcall==
![[MW35.png]]



`push ecx` (carica in memoria ecx e sposta il puntatore in alto di 4 byte)
`push 10` (carica in memoriav valore 10 e sposta il puntatore in alto di 4 byte)
`push 30` (carica in memoria valore 30 e sposta il puntatore in alto di 4 byte)
`call substract` (chiama la funzione di sottrazione)

**_Inside the substract function_**:
prima di tutto viene memorizzato in memoria il `return address`
`push ebp` (carica in memoria ebp e sposta il puntatore in alto di 4 byte)
Da qui, ci spostiamo da ebp+8 (dato che abbiamo aggiunto due cose nello stack, per fare riferimento al primo argomento utile bisogna fare salti di 4 a partire da ebp+8)
`sub eax, edx` (si effettua la sottrazione)


`push EBP`: it's responsibility of the collee function. If you want to use the base pointer. you have to save it.

So this is why every function that you will see generated by a compiler it's gonna do push ebp as the first instruction.

What we push we should pop in the reverse order.

```

## Caller-save VS Callee-save
- **Caller-save** registers are pushed to the stack before a call, if the caller is going to use their values after the call ( typically EAX, ECX, EDX )
- **Callee-save** registers are pushed to the stack in the prologue of the callee when it needs to use them (  typically EDI, ESI, EBX  )

Compilers often prefer callee-save registers for performance: when register pressure gets high, also caller-save registers are used. But in custom code we can find any sort of assortment… 

## EBP - Enter and Leave
When used as base pointer a function prologue may set EBP with:
`push ebp`
`mov ebp, esp`
This can be done with a single instruction: `enter`
(optional immediate subtracted from ESP to make room for local variables)

To leave a function, ESP must point to the caller’s return address. 
EBP may come to the rescue in a function epilogue: 
`mov esp, ebp` 
`pop ebp` 
This can be done with a single instruction: `leave`

## LEA Instruction
==LEA (Load Effective Address)== evaluates an expression that defines a memory address and writes it to a destination register.
-  data movement and ALU instructions dereference a given address and operate on the content of the pointed location 
- LEA simply computes an address!

Two different uses:
1. Address calculation (pointer arithmetic)
2. Arithmetic Expression

>When we find the LEA that works on memory, you are not reading that memory but you are computing the address.


```ad-question
title: What is the difference between `MOV` and `LEA`?
With `move` we are referencing to the pointer.
With `LEA` we are computing the pointer.

## Caso 1: `MOV eax, [ebx]`
`mov eax, [ebx]`
- **Interpreta `[ebx]` come un indirizzo di memoria**.
- Legge il **contenuto della memoria** all’indirizzo contenuto in `ebx` e lo mette in `eax`.
    

Esempio:
- `ebx = 0x1000`
- memoria[0x1000] = `0xDEADBEEF`

Risultato:  
`eax = 0xDEADBEEF`

👉 Quindi `MOV` fa un **accesso in memoria**.


## Caso 2: `LEA eax, [ebx]`
`LEA eax, [ebx]`

- Qui `LEA` **non legge la memoria**.
- Calcola solo l’“effective address” (cioè l’espressione dentro le parentesi quadre) e lo mette in `eax`.
  
Esempio con stessi valori:
- `ebx = 0x1000`
- memoria[0x1000] = `0xDEADBEEF`

Risultato:  
`eax = 0x1000`

👉 Quindi `LEA` mette in `eax` **l’indirizzo stesso**, non ciò che c’è in memoria.



Esempio:
![[MW40.png]]

```


```ad-example
![[MW36.png]]

```

## Rep Instructions
```ad-abstract
title: Definition
Special instructions that we can use for implementing memory and string manipulations

```

Special instructions for manipulating bytes in buffers 
- `cmpsb` to compare bytes from two buffers 
- `stosb` to initialize all bytes in a buffer with same value 
- `movsb` to copy one buffer into another 
- `scasb` to search a byte in a buffer 

L’istruzione `REP` (o `REPE` / `REPNE`) serve a dire al processore:
```ad-cite
“Ripeti questa istruzione tante volte quante indicate in **ECX**”.  Ogni volta che l’istruzione viene eseguita, `ECX` viene decrementato di 1.

```

Quando `ECX == 0`, la ripetizione finisce.

**_Registri coinvolti_**
- `EDI` → contiene l’indirizzo della **destinazione** (es. buffer dove scrivere o cercare).
- `ESI` → contiene l’indirizzo della **sorgente** (es. buffer da leggere/copiare).
- `AL` → contiene il **byte da usare**:
    - in `stosb`, è il valore da scrivere nel buffer;
    - in `scasb`, è il valore da cercare.
### Concetti fondamentali
- `ECX` è il **contatore**: contiene il numero di byte da processare (in 32-bit).
- `ESI` punta alla **sorgente** (source).
- `EDI` punta alla **destinazione** (destination).
- `AL` contiene il **byte** usato da `stosb` o cercato da `scasb`.
- `REP <instr>` ripete `<instr>` finché `ECX == 0`.
- `REPE` / `REPZ` e `REPNE` / `REPNZ` sono usati con `cmpsb`/`scasb`: ripetono finché `ECX==0` **o** finché la condizione sul flag zero (`ZF`) è soddisfatta/negata (es. fermarsi alla prima differenza o al primo match).

```ad-important
con **REP + le string instructions** (`movsb`, `stosb`, `cmpsb`, `scasb`), la CPU fa automaticamente dei loop efficienti su memoria e stringhe. In reverse engineering, quando le vedi, devi subito pensare a quelle funzioni della libc.

```


```ad-info
title: Per IDA (PRACTICAL PART)
In **IDA**, quando apri un file scritto in **C**, potresti notare che l’esecuzione non inizia direttamente dal `main`. Questo succede perché, nell’**header dell’eseguibile**, il compilatore indica al loader del sistema operativo di avviare l’esecuzione da un altro punto.

In altre parole, prima che il programma arrivi al codice che hai scritto, devono avvenire alcune operazioni preliminari. Ad esempio:

- Vengono letti e processati gli **argomenti della linea di comando**, se ne hai passati.
    
- Possono essere effettuate **verifiche di compatibilità**, come la versione del sistema operativo o le capacità della CPU.
    
- Alcuni controlli specifici legati al compilatore o alla CPU target possono essere eseguiti, soprattutto se l’eseguibile è compilato per un processore particolare.
    

Questi passaggi servono a preparare l’ambiente in cui il `main` potrà poi essere eseguito correttamente.

>The last things that we pushed is the first to be popped!

```

`.idata` si riferisce all'import di funzioni esterne!
tls. Callback is a mechanism of windows that implements thread local storage.

```ad-important

`leave` è una scorciatoia che, **alla fine della funzione**, rimette `esp = ebp`, riallineando lo stack senza che tu debba farlo manualmente, e poi recupera il vecchio frame pointer.

`leave` farà il `POP` del push di `EBP`
```
# Esempio 1

```C
int **attribute**((stdcall)) mysum(int a, int b, int c) { 
	return a + b + c; 
} 

void test() { 
	int result = mysum(32, 64, 96);
	int expected = 32 + 64 + 96;
	printf("%d == %d\n", result, expected);
} 

int main() { 
	test(); return 0;
}
```

![[preview.webp]]

Nelle architetture x86/x86-64 con frame pointer, le variabili locali stanno SEMPRE "prima" (sotto) di EBP.

### Prologo
```assembly
push    ebp           ; Salva il base pointer
mov     ebp, esp      ; Crea nuovo frame pointer
sub     esp, 40h      ; Alloca 64 bytes per variabili locali (5 X 8)
```

### Preparazione Parametri Chiamata
```assembly
mov     dword ptr [esp+8], 96    ; 3° parametro (c = 96)
mov     dword ptr [esp+4], 64    ; 2° parametro (b = 64)
mov     dword ptr [esp], 32      ; 1° parametro (a = 32)
```

Questi sono i tre parametri passati a `mysum(32, 64, 96)`. Vengono messi sullo stack perché la funzione usa la convenzione `__stdcall`.

### Chiamata di funzione
```assembly
call    stdc_401460   ; Chiama mysum
sub     esp, 12       ; Pulisce i parametri (3 × 4 bytes)
mov     [ebp-12], eax ; Salva il risultato in var_C (result)
```
eax contiene il valore di ritorno della funzione `mysum`
L'ultima istruzione, copia il valore da eax nella memoria all'indirizzo `ebp-12` ovvero result

### Calcolo del Valore Atteso
```assembly
mov     dword ptr [ebp-16], 192  ; expected = 192 (32+64+96)
```
IDA ha ottimizzato il calcolo `32 + 64 + 96` direttamente a 192 in fase di compilazione.

### Preparazione per Printf
```assembly
mov     eax, [esp+16]    ; Carica 'expected'
mov     ecx, [ebp-16]    ; (altro accesso a expected)
mov     eax, [ebp-12]    ; Carica 'result'
mov     [esp+4], eax     ; 2° arg: result
mov     dword ptr [esp], offset Format  ; 1° arg: "%d == %d\n"
call    printf
```

### Mappatura Variabili
- `var_C` ([ebp-12]) = `result` - il valore ritornato da `mysum`
- `var_10` ([ebp-16]) = `expected` - valore precalcolato 192
- `Format` = stringa `"%d == %d\n"`

```ad-question
Perchè ho sottratto da EBP e non da ESP?

```

```
Stack (cresce verso il basso ↓) 
================================                   (INDIRIZZI ALTI (0X1000))
[parametri funzione] [indirizzo di ritorno] 
ebp → [vecchio ebp salvato] ← Base del frame corrente     
ebp-4 [variabile locale 1] 
ebp-12 [variabile locale 2 = result] 
ebp-16 [variabile locale 3 = expected] 
esp → [top dello stack] ← Dopo "sub esp, 40h" 
================================                   (INDIRIZZI BASSI (0X0FC0))
```

```ad-success
title: Risposta
Perché sottraiamo?
1. Lo stack **cresce verso il basso** (da indirizzi alti a indirizzi bassi)
2. `ebp` punta alla **base** (parte alta) del frame corrente
3. Le variabili locali vengono allocate **sotto** `ebp`, quindi verso indirizzi più bassi
4. Per accedervi usiamo offset negativi: `ebp-4`, `ebp-8`, `ebp-12`, ecc.

```

```ad-important
`sub esp, 40h` stai **sottraendo** 40h (64 in decimale) da ESP, non aggiungendo!
```
## Regola fondamentale:
- **`sub esp, N`** = alloca N bytes (ESP si sposta verso il basso, indirizzi più bassi)
- **`add esp, N`** = dealloca N bytes (ESP si sposta verso l'alto, indirizzi più alti)

- **EBP** (Base Pointer) = punta alla **base** del frame (indirizzo alto)
- **ESP** (Stack Pointer) = punta alla **cima/top** dello stack (indirizzo basso)


```assembly
Dopo CALL test() (push automatico del return address): 

================================ 
[return address] ← Pushed automaticamente 
esp → [qui] 
================================ 

Dopo PUSH EBP: 

================================ 
[return address] 
[vecchio ebp] ← Salvato 
esp → [qui] ← ESP si è abbassato di 4 
================================ 

Dopo MOV EBP, ESP: 

================================ 
[return address] 
ebp → [vecchio ebp] ← EBP ora punta qui! 
esp → [qui] ← ESP stesso posto 
================================ 
↑ Questa è la BASE del NUOVO frame! 

Dopo SUB ESP, 40h:
 
================================ 
[return address] 
ebp → [vecchio ebp] ← BASE (EBP fisso)
[spazio 64 bytes] 
esp → [qui] ← TOP (ESP abbassato) 
================================
```

# Esempio 2

![[preview 1.webp]]

```C
void fun_while() {
	while (B % 4 != 0) {
		 C += A_2; 
		 B--; 
	 } 
} 

int main(int argc, char_ argv[]) { // feel free to change this as you like! 
	A = 30; B = 21; C = 3; 
	fun_while(); 
	return 0; 
}
```

### Struttura del Ciclo While
```c
while (B % 4 != 0) {
    C += A*2;
    B--;
}
```
### Prologo funzione 
```
push    ebp
mov     ebp, esp
jmp     short loc_401501    ; Salta DIRETTAMENTE alla condizione!
```
**Importante**: Il compilatore ottimizza saltando subito al controllo della condizione prima di eseguire il corpo del loop.

### Condizione del while (`loc_401501`)
```
loc_401501:
mov     eax, ds:_B          ; Carica B in eax
and     eax, 3              ; eax = B & 3  (equivale a B % 4)
test    eax, eax            ; Controlla se eax == 0
jnz     short loc_4014E0    ; Se NON zero, vai al corpo del loop (0 = false -> condizione non rispettata)
```
**Trucco di ottimizzazione**:
- `B % 4` è sostituito con `B & 3` (più veloce!)
- `x % 4 == x & 3` perché 4 = 2², quindi prendi gli ultimi 2 bit
- `test eax, eax` controlla se il risultato è zero
- `jnz` = "jump if not zero" → se `B % 4 != 0`, esegui il corpo

### Corpo del Loop (`loc_4014E0`)
```
loc_4014E0:
mov     eax, ds:_A          ; Carica A
lea     edx, [eax+eax]      ; edx = A + A = A*2 (LEA trick!)
mov     eax, ds:_C          ; Carica C
add     eax, edx            ; eax = C + A*2
mov     ds:_C, eax          ; Salva in C
mov     eax, ds:_B          ; Carica B
sub     eax, 1              ; eax = B - 1
mov     ds:_B, eax          ; Salva in B (B--)
```
**Ottimizzazioni interessanti**:
- `lea edx, [eax+eax]` = modo furbo per fare `A*2` senza moltiplicazione!
- LEA (Load Effective Address) calcola indirizzi ma qui è usato per aritmetica veloce

### Ritorno al Controllo
Dopo il corpo, il flusso torna automaticamente a `loc_401501` per ricontrollare la condizione.

### Uscita dal Loop
```
nop
pop     ebp
retn                        ; Torna al chiamante
```
Quando `B % 4 == 0`, il `jnz` non salta e si esce dal loop.



>Remember, CPU see only a list of commands and instructions


---

# Laboratory 3
Answer the following questions: 
1) When was this file compiled? `Thu May 14 19:12:41 2009`
2) List a few imports or sets of imports and describe how the malware might use them. 
	`readfile` and `writefile`, `shellexecuteExA` (Performs an operation on a specified file.), `createpipe`
3) What are a few strings that stick out to you and why? 
	All the strings inside the blacklist. In particular GetStartupInfo because it allow to obtain useful data from the startup, also setProcessPriorityBoost and SetThreadPriority because can change the priority for a certain and specific thread/process.
4) What happens when you run this malware? Is it what you expected and why? 
	cdscs
5) Name a procmon filter and why you used it. 
6) Are there any host-based signatures? (Files, registry keys, processes or services, etc). If so, what are they? 
7) Are there any network based signatures? (URLs, packet contents. etc) If so, what are they?
8) Is there anything that impeded your analysis? How so? How might you overcome this?
9) What do you think is the purpose of this malware?

## Parte teorica
Per prima cosa analizziamo il file `lab_03-1` usando ==pestudio 8.56==. Pestudio ci fornisce un’analisi statica rapida e dettagliata: tra le informazioni di maggior interesse ci sono le librerie importate, le stringhe contenute nel binario, le sezioni del file PE, gli export/import, le risorse e gli indicatori di sospetto (packer, anomalie nelle sezioni, ecc.). Questi elementi ci permettono di rispondere in modo documentato alle prime tre domande dell’esercizio, perché rivelano quali API vengono chiamate, possibili URL o comandi nascosti nelle stringhe e quali capacità il programma potrebbe avere (es. manipolazione di file, rete, creazione di processi, elevazione di privilegi).

Per la parte finale della lezione svolgiamo un’analisi dinamica con ==Process Monitor (Procmon)==. Procmon cattura in tempo reale tutte le operazioni a livello di sistema: attività su file, chiavi di registro, creazione/terminazione di processi, attività di rete (se abilitata) e accessi alle risorse. La procedura tipica che seguiamo è:

1. avviare Procmon per iniziare la cattura;
2. eseguire `malware.exe` (fase di esecuzione/trigger);
3. arrestare la cattura quando ritenuto sufficiente;
4. ispezionare i log raccolti.

Durante l’analisi possiamo applicare filtri mirati per ridurre il rumore — per esempio filtrare per **PID** del processo in esame, per nome del processo, per operazione (CreateFile, RegSetValue, CreateProcess, ecc.) o per percorso file/chiave di registro. Questo ci consente di isolare le azioni compiute dal binario infetto e seguire la catena di attività (ad es. un processo che crea un file, poi avvia un altro processo, poi modifica una chiave di registro per persistenza).

Infine confrontiamo i risultati statici di **pestudio** con quelli dinamici osservati in **Process Monitor**. In pratica:
![[MW112.png]]Lab_03-1.exe is performing action process create whose target is cmd.exe and in fact, one moment later, we have this new process with PID 4772 that is our shell
![[MW113.png]]


```ad-note
title: Spiegazione parte pratica Process Monitors
**_Preparazione: Creazione di Thread e Caricamento di DLL_**
Prima dell'azione principale, il malware si sta preparando all'esecuzione.

- **`Thread Create`**: Il processo `Lab_03-1.exe` (PID: 6452) crea diversi nuovi thread (con ID 6760, 1500, 6568, etc.). Questo è un comportamento normale per un'applicazione che vuole eseguire più operazioni in parallelo.
- **`Load Image`**: Il processo carica diverse DLL di sistema nel suo spazio di memoria. Queste sono librerie legittime di Windows necessarie per funzionare (es. `wincon.dll` per la console, `WinTypes.dll` per i tipi di dati Windows). Questo indica che il malware si sta "initializzando" e preparando a usare le funzioni del sistema operativo.

**_2. L'Azione Malevola Principale: Creazione di un Processo_**
Questo è il punto cruciale dell'analisi.
- **`Process Start`**: Alle **1:40:52.1355044 PM**, il processo `Lab_03-1.exe` (PID: 6452) avvia un **nuovo processo**.
- **Percorso del nuovo processo**: `C:\Windows\SysWOW64\cmd.exe`
- **Risultato**: **SUCCESS**
- **PID del nuovo processo**: **4772**

**Cosa significa?** Il malware ha lanciato con successo il Prompt dei comandi di Windows. Questo è un comportamento altamente sospetto per un'applicazione comune e un classico indicatore di attività malevola.

**_Analisi della Chiamata di Processo (Event Properties)_**
La finestra in basso, "Event Properties", fornisce dettagli fondamentali sull'evento di "Process Create".
- **PID: 4772**: Conferma che il nuovo processo `cmd.exe` è stato avviato con questo ID.
- **Parent PID: 6452**: Questo è un dato **fondamentale**. Conferma che il padre (il creatore) di `cmd.exe` è proprio il nostro malware `Lab_03-1.exe`. Non è un processo di sistema avviato indipendentemente.
- **Command Line**: `"C:\Windows\system32\cmd.exe" / "C:\Users\student\Desktop\Lab03\Lab_03-1.exe > nd"`

**Analisi della Command Line:**  
La riga di comando è un po' corrotta (`/ "C:\Users...`), ma il concetto è chiaro. Il malware sta tentando di eseguire `cmd.exe` e di reindirizzare l'output (l'operatore `>`) verso un file o un dispositivo. La presenza di una stringa di comando complessa è un altro forte indicatore di malevolenza.


**_Collegamento con l'Analisi Statica_**
L'analista fa una nota cruciale:

> "Notare che qui è presente una stringa che era all'interno della blacklist quando abbiamo effettuato l'analisi statica con **pestudio**!"

**Cosa significa questo collegamento?**

1. **Analisi Statica (con PEstudio)**: Prima di eseguire il malware, l'analista lo ha esaminato senza avviarlo. Strumenti come PEstudio analizzano il file binario e estraggono stringhe di testo in chiaro al suo interno. In quella fase, hanno trovato una "blacklist" di stringhe sospette (es. `"cmd.exe"`, `"powershell.exe"`, comandi di rete, etc.).
2. **Analisi Dinamica (con Process Monitor)**: Ora, durante l'esecuzione, l'analista **vede in azione** una di quelle stringhe sospette che aveva visto nella lista nera. In questo caso, la stringa è la riga di comando che avvia `cmd.exe`.

**Questo è il momento "Eureka!" dell'analisi:** l'ipotesi di malevolenza formulata durante l'analisi statica viene **confermata empiricamente** dall'analisi dinamica. Il malware fa esattamente ciò che le sue stringhe suggerivano.

```



