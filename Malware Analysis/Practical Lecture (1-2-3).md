>In this course we will use the Intel syntax
# x86
Reverse engineering of binary code is difficult. 
Thankfully, only some portions of a malware sample really require it 
==FACT==: malicious code $\not =$ compiler-generated code 
- hand-written sequences 
- self-modifying code 
- subtle semantics (e.g., jump in the middle of an instruction) 
- obfuscation of control and data flows 
- other decoys

## DECOMPILATION?
Decompilers (e.g., Ghidra, Hex-Rays) try to reconstruct a high-level C-like representation of a binary code fragment.
**Process far from perfect **
- information loss during compilation (e.g., types, identifiers) 
- decompiling obfuscated code returns an obfuscated source 
- anti-analysis techniques ‚ñ™Nevertheless, helpful for reverse-engineering professionals

## CPU and Memory Basics
![[MW4.png]]
RAX, RBX, RCX, RDX: Those are the registers where normally you put your data to have the CPU work on this data.
## ISA AND X86
==Instruction Set Architecture (ISA)== = abstract model describing what a programmer should know to program the machine. (Language of the CPU)

==ISA== ‚âà interface between software and hardware. Humans or compilers produce ISA-conformant assembly code, then an assembler encodes it in a binary format understood by hardware 

- Intel defined the x86 ISA for its 8086 processor (1976-1978) 
	- Later extensions preserved backward compatibility 
	- Today most malware is still 32-bit 
	- x86 is also known as IA-32 
	- x86-64 (x64 for short) is the 64-bit successor 

## WORD SIZE AND ENDIANNESS
A word is the natural data unit for a specific CPU design. For x86 processors, the word size is 32 bits
However, for backward compatibility, x86 instructions assume a word operand to be 16-bit long, while a dword operand is 32-bit long. IA32 common data types: byte, word, dword
Memory always operates at byte level. Endianness specifies how multi-byte sequences are read from/written to memory.

![[MW5.png]]

>In the first, the most important word is "AB".

```ad-info
Intel is little endian.
The others are big endian.

```


word us 16-bit,to refers to 32 we have to say "double word", to refers to 64 we have to say a "quad-word". The concept of word is 32'bit then in assembly there is the subtle difference.

## REGISTERS
Coders use (many) variables. CPUs work on (few) registers 
Registers hold data with fast access time:
	==General-purpose registers (GPRs)== can store data or memory addresses 
	==Status register== holds truth values on the state of the processor after the last executed instruction (used, for example, in conditional computations) 
	==Program counter== holds the address of the instruction being executed 
	Many other registers 
x86 general-purpose registers are 32-bit wide

### ACCESSING REGISTERS
![[MW6.png]]

If i want the entire register i should call it by this name for entirely: EAX (E significa extended, perch√© inizialmente prendere tutto il registro, che era a 16-bit, significava prendere l'intero contenuto ovvero AX. La E, sta per extension e permette di prendere anche gli altri 16 bit aggiuntivi).

```ad-important
==Status== and ==program counter== registers, there is no way to modify them directly!

```

>H stay for higher and L stay for lower

>Registers are 32-bit

## INSTRUCTION CYCLE
 Fetch-decode-execute cycle: 
 - ==Fetch (prelievo dell‚Äôistruzione)==
    - La CPU prende dalla memoria l‚Äôistruzione che si trova all‚Äôindirizzo contenuto nell‚Äô**EIP** (Instruction Pointer, oggi chiamato **RIP** nei sistemi a 64 bit).
    - EIP quindi indica sempre **dove si trova la prossima istruzione**.
- ==Decode (decodifica dell‚Äôistruzione)==
    - L‚Äô**unit√† di controllo (Control Unit)** interpreta l‚Äôistruzione prelevata, cio√® capisce che operazione bisogna fare.
    - Qui si distinguono gli **operandi** (su cosa lavorare) e l‚Äô**opcode** (che operazione svolgere).
- ==Execute (esecuzione)==
    - L‚Äôistruzione viene eseguita: pu√≤ essere un calcolo fatto dall‚Äô**ALU** (somma, sottrazione, ecc.) oppure un trasferimento di dati (da memoria a registro, da registro a registro, ecc.).
    - Al termine, l‚Äô**EIP** viene aggiornato all‚Äôistruzione successiva, a meno che l‚Äôistruzione non cambi esplicitamente il flusso (es. `jmp`, `call`, `ret`).
 Then EIP advances to the next adjacent instruction, unless current instruction explicitly altered the control flow (e.g., with a jump)

```ad-example
> ‚ÄúThe letters A, P, P, L, E, that‚Äôs an instruction...‚Äù

Immagina la memoria come un libro scritto in **byte** (sequenze di 8 bit).

- Se la CPU legge i primi 5 byte `41 50 50 4C 45` (che corrispondono in ASCII ad ‚ÄúAPPLE‚Äù), quello √® il **fetch**.
    
- Poi la CPU **decode**: riconosce che quei byte hanno un significato come istruzione.
    
- Infine **execute**: compie l‚Äôazione richiesta da quell‚Äôistruzione.
    

Quindi la CPU non vede lettere o parole, ma **sequenze di byte** che hanno senso solo secondo il set di istruzioni (ISA, Instruction Set Architecture).

```

 Instructions vary in size (1-15 bytes) and are stored consecutively in memory along with any immediate operands (i.e., data or addresses) they might use. Register operands are embedded instead in the opcode binary representation:
 
```bash
b8 01 00 00 00 mov eax, 0x1 
bf 01 00 00 00 mov edi, 0x1 --littleendian
```

`b8` √® l‚Äô**opcode** che significa ‚Äúmuovi un valore immediato dentro `eax`‚Äù.
I 4 byte successivi `01 00 00 00` rappresentano il numero **0x1** in **little-endian** (cio√® byte meno significativo per primo).
Quindi tutta l‚Äôistruzione occupa 5 byte. Allo stesso modo:
`bf` √® l‚Äôopcode che significa ‚Äúmuovi un valore immediato dentro `edi`‚Äù.
Segue il valore immediato `01 00 00 00`.

# MEMORY ADDRESSING
Addressing modes provide a way to express the addresses of data to be read from/written to the main memory.
Expressions can take immediate operands, registers, or both.
Addressing modes enable operand combinations to compute complex expressions that depend on the program state.
Usually, an instruction can have at most one memory operand.

>We cannot have the same operation that read and write in the same time.

## COMMON ADDRESSING MODES
Some popular ways to specify data to be read from/written to the main memory. For the last two rows, the offset field is optional.

| Mode                      | Intel Syntax             |
| ------------------------- | ------------------------ |
| Immediate                 | Mov eax, $[0x1000]$      |
| Register                  | mov eax,$[esi]$          |
| Register + Offset         | mov eax,$[esp-8]$        |
| Register*width + Offset   | mov eax, $[ebx*4+0xff]$  |
| Base + Reg*width + Offset | mov eax, $[edx+ebx*4+8]$ |
>Ogni volta che, analizzando la memoria, vedo le parentesi quadre significa che sto accedendo alla memoria.

```ad-example

In the first line of the table, we are moving into the register A what is written in memory at address $[0x1000]$.
```

## INTEL VS. AT&T SYNTAX
x86 assembly has two main syntax types: AT&T and Intel. Intel syntax is dominant in the Windows world. Relevant differences:

![[MW7.png|400]]

## MEMORY MAP OF A PROCESS
It illustre how a windows process for a program is orchestrated!

Quando lanci un programma su Windows, il sistema operativo crea un **processo** e gli assegna uno **spazio di indirizzamento virtuale**.  
In architettura a 32 bit, questo spazio √® di **4 GB (2¬≥¬≤ indirizzi)**. Windows lo divide in:
- **2 GB inferiori (0x00000000 ‚Äì 0x7FFFFFFF): spazio utente**
- **2 GB superiori (0x80000000 ‚Äì 0xFFFFFFFF): spazio kernel** (non mostrato nell‚Äôimmagine).
Quello che vedi √® una **mappa semplificata** della met√† ‚Äúuser space‚Äù.

![[MW8.png]]

>Grey area are inaccessibile!

==Stack==: Parte dall‚Äôalto (indirizzi alti, vicino a 0x7FFFFFFF) e cresce verso il basso (indirizzi pi√π bassi), cos√¨ pu√≤ espandersi senza interferire subito con heap e codice. Utilizzato per variabili locali, return delle funzioni, frame di esecuzione.

==Heap==: Cresce dal basso verso l‚Äôalto (indirizzi crescenti). Usato per l‚Äô**allocazione dinamica** (Callo, Malloc, Calloc) ed √® gestito dal processo e dal runtime, non cresce automaticamente come lo stack.

==Program Image==: Qui viene caricato l'eseguibile.

==Spazio Allocabile==: Zona intermedia che pu√≤ essere usata per heap aggiuntivo o stack di altri thread.

==DDL==: Dynamic Link Library, DLL are the libraries for Windows. A library is a code module that contains. Functionality that is implemented by the operating system, or some support third-party package, which offers you programming capabilities

==TEB, PEB, shared user page==: Space for some page, which contain a number of features that the operating system places there.

```ad-example
title: Example on Stack
- Lo **stack cresce verso indirizzi bassi**.
    
- Se ho lo stack pointer (ESP) = `0x7FFD0000` e faccio una `push`, il valore viene scritto a `ESP - 4`.
    
- Perci√≤ **aggiungere dati significa sottrarre all‚Äôindirizzo**.
    
- Se al contrario **aumento ESP (con add)**, sto ‚Äúshrinkando‚Äù (riducendo) lo stac

```

>On Windows, any executable file, a binary, a program that you can run, It's called Portable Executable, PE.

>the stack grows to low addresses. I want more space, so up, I have to subtract from this value. And if I'm adding, this means that I'm shrinking the stack.

## MEMORY PROTECTION
**Paging** mechanisms 
- determine whether an address is valid 
- enforce read/write/execute permissions (granularity: regions) 
- pages in kernel memory are accessible only from kernel code 

Operating systems may enforce high-level security mechanisms to hinder memory vulnerability exploitation attacks 
- DEP (Data Execution Prevention) 
- ASLR (Address Space Layout Randomization) 
- Heap allocation randomization & other protections in Windows 10+

Memory is partitioned in chunks, each page as a site and within a page, the permission are fixed for the page. So a page and all the bytes in it can be readable, can be writable, can be executable, you can set it individually. But two bytes in the same page, they cannot have different permissions.
You use paging for, first of all, determining address validity, so to block all the cases where the program is trying to access memory that is either not valid. Then you can enforce security permissions.

On the hardware, we use it to differentiate what are the pages that only the kernel can read, and, I mean, to separate the 2GB for kernel and the 2GB for the users.

## BASIC X86 INSTRUCTIONS
Programs are made of three kinds of instructions:
- Data movement 
- Arithmetic & logic 
- Program flow control

Data movement instructions are straightforward:
 mov dest, src 
 Copy {register, memory content, immediate} to {register, memory location} 
 
 push src 
 pop dest 
 Used for stack manipulation (we will talk about them in a while‚Ä¶) 

## ARITHMETIC INSTRUCTIONS
These instructions are relevant for code analysis for many reasons 
- computing offsets and function addresses 
- stack pointer modification 
- used also for data movement or to update EFLAGS

![[MW9.png]]

## LOGIC INSTRUCTIONS
Common instances 
- zero-ing registers: xor eax, eax 
- extracting bits and checking conditions 
- obfuscation 
Beware that these operations are bit-wise. High-level logical operations such as && and || have a very different semantics.

![[MW10.png]]

## ROTATE/SHIFT INSTRUCTIONS
Frequently encountered in bit manipulations: (when src is absent, a default of 1 is assumed) 
![[MW11.png]]
## PROGRAM FLOW CONTROL
Control flow can be implemented in three ways:
- ==Unconditional branch==: EIP is replaced with some desired address 
- ==Conditional branch==: EIP is replaced with some desired address depending on the value of one or more bits from EFLAGS
- Function ==calls== and ==returns==: special type of unconditional branches.
Two primitives needed: 
- a way to specify the target of a branch (static or dynamic) 
- a way to evaluate a condition on the program state 
Code locations in assembly can be annotated with labels 
### UNCONDITIONAL BRANCHING
An unconditional branch can take as destination:
- an **offset**, specified as a relative offset from the current EIP value or as an absolute offset (from the base of the current code segment‚Ä¶) 
- or an **absolute address**, provided as a register or memory operand 

![[MW12.png]]
### CONDITIONAL BRANCHING
Conditional branches evaluate conditions over selected bits of the EFLAGS register. Common cases:
- **CF** (carry flag), meant for errors in unsigned arithmetics 
- **OF** (overflow flag), meant for errors in signed arithmetics 
- **SF** (sign flag), set when the result of an operation is negative 
- **ZF** (zero flag), set when the result of an operation is zero

We can use the cmp instruction to compare two values: cmp dest, src computes the difference dest-src without modifying dest, and sets the flags above in a way that enables many useful comparisons‚Ä¶ 

- A jcc instruction checks the condition specified by cc suffix and jumps to the given offset accordingly (no absolute addresses) 
- Say we just executed cmp D, S:

![[MW13.png]]

Another common comparison instruction is test 
- it computes the bitwise AND of its operands without altering them 
- say we want to check whether register D holds zero as value: test D, D will set the zero flag iff. $D==0$, then **jz** can be used

But malware won‚Äôt use only cmp and test. Say, you can decrement a value with dec or sub and then check if the instruction set the zero flag with **jz** ü§ß (also optimizing compilers do that!)

## Function and Stack Frames
```ad-abstract
title: Definition of Function
Unit of code that controls register values and its portion of stack independently of other units
- if a code unit calls another, the latter should not clobber registers in use 
- CPUs come with few general-purpose registers: one can spill (i.e., save) some values on the stack and fetch them later in the execution as needed


```

>Every function have a specific stack.
### Stack Frames
Lo stack √® concettualmente suddiviso in _frame_, uno per ogni funzione attualmente attiva.  
Un frame contiene tipicamente:

- gli **argomenti** passati alla funzione,
- le **variabili locali** e altri dati temporanei,
- l‚Äô**indirizzo di ritorno** (return address), ovvero il punto del programma in cui riprendere l‚Äôesecuzione dopo l‚Äôuscita dalla funzione.
### Gestione dei Registri
Le CPU dispongono di un numero molto limitato di registri generali.
- Quando una funzione (es. **A**) chiama un‚Äôaltra funzione (es. **B**), quest‚Äôultima non pu√≤ sapere quali registri siano gi√† in uso da **A**.
- Per evitare conflitti, vengono stabilite delle **calling conventions**: regole che definiscono quali registri devono essere preservati e quali possono essere liberamente usati.
- Poich√© i registri non sono mai sufficienti per tutte le variabili, alcune devono essere salvate sullo stack e ricaricate quando necessario.

### Stack Pointer
Il **puntatore allo stack (SP)** √® un registro speciale che indica la cima dello stack.
- In teoria √® un registro generale, ma in pratica non deve essere modificato arbitrariamente.
- Serve a mantenere l‚Äôordine corretto delle allocazioni temporanee e a gestire i frame delle funzioni.

### Importanza del Return Address
Il **return address** √® fondamentale: senza di esso, il programma non saprebbe dove riprendere l‚Äôesecuzione dopo la fine di una funzione.
- Quando una funzione viene chiamata, l‚Äôindirizzo dell‚Äôistruzione successiva alla call viene salvato nello stack.
- Alla fine della funzione, l‚Äôistruzione `ret` recupera questo indirizzo e l‚Äôesecuzione continua dal punto giusto.

## Locale Storage
Suppose we don‚Äôt have free registers left and we would like to add to EDX the difference between EBX and ECX:

![[MW30.png]]

## PUSH AND POP INSTRUCTIONS
- `push src` moves the top of the stack up by 4 bytes, then copies the content of the operand (immediate or register) to the address pointed by the updated ESP 
- `pop dest` copies the 4 bytes currently pointed by ESP to the dest register, then moves the top of the stack down by 4 bytes 
- ==push/pop operations== can also be realized via sub/add + mov:

![[MW31.png]]

```ad-missing
title: Problem
Quando una funzione esegue delle operazioni sullo **stack** (ad esempio `push` di valori o allocazione di variabili locali), il **Stack Pointer (SP)** si sposta di conseguenza.

- Ogni `push` decrementa lo stack pointer (dato che lo stack cresce verso il basso in memoria).
    
- Ogni `pop` lo incrementa.
    

Il problema √® che, se durante l‚Äôesecuzione di una funzione fai molte operazioni di `push` e `pop`, diventa difficile **tenere traccia della posizione originale dello stack**.

Per risolvere questo, si introduce un altro registro: il **Base Pointer (BP)**, spesso chiamato anche **Frame Pointer (FP)**.

#### Meccanismo tipico:

1. **Entrata nella funzione**:
    
    - Salvo il valore corrente del base pointer sullo stack (`push ebp` in x86).
        
    - Copio lo stack pointer dentro il base pointer (`mov ebp, esp`).  
        ‚Üí In questo modo, **EBP** diventa un ‚Äúpunto di riferimento stabile‚Äù per l‚Äôintera funzione.
        
2. **Durante la funzione**:
    
    - Posso spostare lo stack pointer (`esp`) per allocare spazio a variabili locali.
        
    - Posso fare `push` e `pop` liberamente.
        
    - Ma i riferimenti agli **argomenti** e alle **variabili locali** li faccio sempre rispetto al **base pointer**, che resta fisso.
        
        - Esempio: `[ebp+8]` ‚Üí primo argomento della funzione
            
        - `[ebp-4]` ‚Üí variabile locale
            
3. **Uscita dalla funzione**:
    
    - Ripristino lo stack pointer riportandolo al valore di **ebp**.
        
    - Recupero il vecchio valore di **ebp** dallo stack (`pop ebp`).
        
    - Infine eseguo `ret`, che usa il return address salvato.

```

## Using The Base Pointer
When entering a function that makes use of local variables, register EBP can be used to reference their locations via fixed offsets

```assembly
mov ebp, esp        ; salva il valore dello stack pointer in ebp
sub esp, 8          ; riserva 8 byte sullo stack (due variabili locali)
mov [ebp-8], 0x1111 ; salva 0x1111 nella variabile locale a offset -8
mov [ebp-4], 0xabadcafe ; salva 0xabadcafe nella variabile locale a offset -4
...
mov eax, [ebp-8]    ; carica 0x1111 in eax

```

![[MW32.png]]

**_Schema a sinistra (prima dell‚Äôallocazione)_**
- `esp` punta all‚Äôultima cella occupata (0x3424).
- Non ci sono ancora variabili locali allocate.

**_Schema a destra (dopo l‚Äôallocazione e scrittura)_**
- `esp` √® sceso di 8 per creare spazio.
- Negli slot allocati troviamo:
    - `[ebp-8] = 0x1111`
    - `[ebp-4] = 0xabadcafe`
- `ebp` resta fisso, a indicare il ‚Äúpunto d‚Äôingresso‚Äù della funzione.
- `esp` invece continua a muoversi se faccio `push` o `pop`.

==L‚Äôidea chiave==:  
Se usassi solo `esp` per accedere alle variabili, ogni `push`/`pop` cambierebbe la loro posizione ‚Üí diventa impossibile seguirle.  
Con `ebp`, invece, ho un **riferimento stabile**: le variabili locali hanno sempre lo stesso offset da `ebp`

## CALL AND RET INSTRUCTIONS

### Funzionamento di `CALL`
- L‚Äôistruzione **`call`** serve per invocare una funzione.
- Diversamente da un semplice **`jmp`**, prima di trasferire il controllo:
    1. **Salva sullo stack** l‚Äôindirizzo dell‚Äôistruzione successiva alla `call`.  
        ‚Üí Questo indirizzo si chiama **return address**.
    2. Salta all‚Äôindirizzo della funzione chiamata (callee).

>In questo modo, al termine della funzione, il programma sa esattamente dove riprendere l‚Äôesecuzione.

```ad-example
![[MW33.png]]

```


### Funzionamento di `RET`
- L‚Äôistruzione **`ret`** viene usata dalla funzione chiamata per **tornare al chiamante (caller)**.
- `ret` preleva dallo stack il **return address** precedentemente salvato da `call`.
- Carica questo indirizzo in **EIP** (Instruction Pointer), cos√¨ l‚Äôesecuzione riprende dal punto corretto.

Il `Return Address` permette di rientrare esattamente dopo la chiamata. Se questo valore viene **corrotto o modificato** (ad esempio in un attacco di buffer overflow), l‚Äôesecuzione pu√≤ essere deviata verso codice arbitrario.

Le funzioni esistono solo come astrazione logica, nel codice macchina non ci sono separatori netti che le distinguono. In memoria il codice √® un flusso continuo di istruzioni.

## Rules Part: Calling Conventions
(At least) two questions left to answer: 
- How are register values preserved across function invocations? 
- How are parameters being passed to functions? 

**_Calling conventions regulate_**
- how parameters are passed (via registers/stack) and in which order 
- which registers the callee must preserve for the caller 
- who performs ESP realignment upon return 

Malware may use custom calling conventions for its functions, but has to follow standard ones to interact with Windows APIs 

```ad-info
title: Appunti miei

For passing arguments we need the stack. The calling convention is also gonna say, who's gonna update the stack pointer to say that these arguments that they passed are no longer needed. we have huge difference between Linux and windows. Malwares can have their custom calling convention.
```
## Windows Conventions
**Convenzioni di chiamata (calling conventions) in Windows**, cio√® di regole su come le funzioni ricevono argomenti, restituiscono valori e gestiscono il registro e lo stack.

Different conventions can be used in the same program 
### 1. `cdecl` (C programs)
**Caratteristiche principali:**
1. **Argomenti passati nello stack, da destra verso sinistra**
    - Se la tua funzione √®, ad esempio, `func(a, b, c)`, allora nello stack l‚Äôordine sar√†: `c`, `b`, `a`
    - Quindi il **primo argomento `a` sar√† l‚Äôultimo a essere scritto nello stack**.
2. **Registri caller/callee-save**
    - **Caller-save**: il chiamante deve salvare `EAX`, `ECX` ed `EDX` se vuole usarli dopo la chiamata.
        - Questo significa che il callee (la funzione chiamata) pu√≤ usare liberamente questi registri senza preoccuparsi di ripristinarli.
    - **Callee-save**: la funzione chiamata deve salvare (`push`) e ripristinare (`pop`) `EBP`, `EBX`, `EDI` ed `ESI` se li usa.
3. **Stack cleanup**
    - **Il chiamante (caller) ripulisce lo stack** dopo il ritorno dalla funzione.
    - Esempio: se la funzione prende 3 argomenti (ognuno 4 byte), dopo il `ret` il caller far√† `add esp, 12` per riportare lo stack alla posizione corretta.
4. **Valore di ritorno**
    - Valore a 32-bit restituito in `EAX`.

### `stdcall` (Win32 API)
**Caratteristiche principali:**
1. **Argomenti e registri**
    - Stesso ordine di `cdecl`: argomenti pushati da destra a sinistra, e stessa regola dei registri caller/callee-save.
2. **Stack cleanup**
    - **Il callee (la funzione chiamata) ripulisce lo stack** prima di ritornare.
    - Questo viene fatto tramite l‚Äôistruzione `ret N`, dove `N` √® il numero di byte da rimuovere dallo stack (tipicamente `N = numero_argomenti √ó 4`).
    - Dopo l‚Äôaggiornamento di `EIP` con l‚Äôindirizzo di ritorno, lo stack viene sistemato automaticamente.

```ad-info
Functions can follow different conventions (linux or windows).

```

```ad-important
![[MW38.png]]

```


```ad-example
title: Example CDECL
==cdecl==
![[MW34.png]]
==Stdcall==
![[MW35.png]]



`push ecx` (carica in memoria ecx e sposta il puntatore in alto di 4 byte)
`push 10` (carica in memoriav valore 10 e sposta il puntatore in alto di 4 byte)
`push 30` (carica in memoria valore 30 e sposta il puntatore in alto di 4 byte)
`call substract` (chiama la funzione di sottrazione)

**_Inside the substract function_**:
prima di tutto viene memorizzato in memoria il `return address`
`push ebp` (carica in memoria ebp e sposta il puntatore in alto di 4 byte)
Da qui, ci spostiamo da ebp+8 (dato che abbiamo aggiunto due cose nello stack, per fare riferimento al primo argomento utile bisogna fare salti di 4 a partire da ebp+8)
`sub eax, edx` (si effettua la sottrazione)


`push EBP`: it's responsibility of the collee function. If you want to use the base pointer. you have to save it.

So this is why every function that you will see generated by a compiler it's gonna do push ebp as the first instruction.

What we push we should pop in the reverse order.

```

## Caller-save VS Callee-save
- **Caller-save** registers are pushed to the stack before a call, if the caller is going to use their values after the call ( typically EAX, ECX, EDX )
- **Callee-save** registers are pushed to the stack in the prologue of the callee when it needs to use them (  typically EDI, ESI, EBX  )

Compilers often prefer callee-save registers for performance: when register pressure gets high, also caller-save registers are used. But in custom code we can find any sort of assortment‚Ä¶ 

## EBP - Enter and Leave
When used as base pointer a function prologue may set EBP with:
`push ebp`
`mov ebp, esp`
This can be done with a single instruction: `enter`
(optional immediate subtracted from ESP to make room for local variables)

To leave a function, ESP must point to the caller‚Äôs return address. 
EBP may come to the rescue in a function epilogue: 
`mov esp, ebp` 
`pop ebp` 
This can be done with a single instruction: `leave`

## LEA Instruction
LEA (Load Effective Address) evaluates an expression that defines a ==memory address== and writes it to a destination register.
-  data movement and ALU instructions dereference a given address and operate on the content of the pointed location 
- LEA simply computes an address!

Two different uses:
1. Address calculation (pointer arithmetic)
2. Arithmetic Expression

>When we find the LEA that works on memory, you are not reading that memory but you are computing the address.


```ad-question
title: What is the difference between `MOV` and `LEA`?
With `move` we are referencing to the pointer.
With `LEA` we are computing the pointer.

## Caso 1: `MOV eax, [ebx]`
`mov eax, [ebx]`
- **Interpreta `[ebx]` come un indirizzo di memoria**.
- Legge il **contenuto della memoria** all‚Äôindirizzo contenuto in `ebx` e lo mette in `eax`.
    

Esempio:
- `ebx = 0x1000`
- memoria[0x1000] = `0xDEADBEEF`

Risultato:  
`eax = 0xDEADBEEF`

üëâ Quindi `MOV` fa un **accesso in memoria**.


## Caso 2: `LEA eax, [ebx]`
`LEA eax, [ebx]`

- Qui `LEA` **non legge la memoria**.
- Calcola solo l‚Äô‚Äúeffective address‚Äù (cio√® l‚Äôespressione dentro le parentesi quadre) e lo mette in `eax`.
  
Esempio con stessi valori:
- `ebx = 0x1000`
- memoria[0x1000] = `0xDEADBEEF`

Risultato:  
`eax = 0x1000`

üëâ Quindi `LEA` mette in `eax` **l‚Äôindirizzo stesso**, non ci√≤ che c‚Äô√® in memoria.



Esempio:
![[MW40.png]]

```


```ad-example
![[MW36.png]]

```

## Rep Instructions
```ad-abstract
title: Definition
Special instructions that we can use for implementing memory and string manipulations

```

Special instructions for manipulating bytes in buffers 
- `cmpsb` to compare bytes from two buffers 
- `stosb` to initialize all bytes in a buffer with same value 
- `movsb` to copy one buffer into another 
- `scasb` to search a byte in a buffer 

L‚Äôistruzione `REP` (o `REPE` / `REPNE`) serve a dire al processore:
```ad-cite
‚ÄúRipeti questa istruzione tante volte quante indicate in **ECX**‚Äù.  Ogni volta che l‚Äôistruzione viene eseguita, `ECX` viene decrementato di 1.

```

Quando `ECX == 0`, la ripetizione finisce.

**_Registri coinvolti_**
- `EDI` ‚Üí contiene l‚Äôindirizzo della **destinazione** (es. buffer dove scrivere o cercare).
- `ESI` ‚Üí contiene l‚Äôindirizzo della **sorgente** (es. buffer da leggere/copiare).
- `AL` ‚Üí contiene il **byte da usare**:
    - in `stosb`, √® il valore da scrivere nel buffer;
    - in `scasb`, √® il valore da cercare.
### Concetti fondamentali
- `ECX` √® il **contatore**: contiene il numero di byte da processare (in 32-bit).
- `ESI` punta alla **sorgente** (source).
- `EDI` punta alla **destinazione** (destination).
- `AL` contiene il **byte** usato da `stosb` o cercato da `scasb`.
- `REP <instr>` ripete `<instr>` finch√© `ECX == 0`.
- `REPE` / `REPZ` e `REPNE` / `REPNZ` sono usati con `cmpsb`/`scasb`: ripetono finch√© `ECX==0` **o** finch√© la condizione sul flag zero (`ZF`) √® soddisfatta/negata (es. fermarsi alla prima differenza o al primo match).

```ad-important
con **REP + le string instructions** (`movsb`, `stosb`, `cmpsb`, `scasb`), la CPU fa automaticamente dei loop efficienti su memoria e stringhe. In reverse engineering, quando le vedi, devi subito pensare a quelle funzioni della libc.

```


```ad-info
title: Per IDA (PRACTICAL PART)
In **IDA**, quando apri un file scritto in **C**, potresti notare che l‚Äôesecuzione non inizia direttamente dal `main`. Questo succede perch√©, nell‚Äô**header dell‚Äôeseguibile**, il compilatore indica al loader del sistema operativo di avviare l‚Äôesecuzione da un altro punto.

In altre parole, prima che il programma arrivi al codice che hai scritto, devono avvenire alcune operazioni preliminari. Ad esempio:

- Vengono letti e processati gli **argomenti della linea di comando**, se ne hai passati.
    
- Possono essere effettuate **verifiche di compatibilit√†**, come la versione del sistema operativo o le capacit√† della CPU.
    
- Alcuni controlli specifici legati al compilatore o alla CPU target possono essere eseguiti, soprattutto se l‚Äôeseguibile √® compilato per un processore particolare.
    

Questi passaggi servono a preparare l‚Äôambiente in cui il `main` potr√† poi essere eseguito correttamente.

>The last things that we pushed is the first to be popped!

```

`.idata` si riferisce all'import di funzioni esterne!
tls. Callback is a mechanism of windows that implements thread local storage.

```ad-important

`leave` √® una scorciatoia che, **alla fine della funzione**, rimette `esp = ebp`, riallineando lo stack senza che tu debba farlo manualmente, e poi recupera il vecchio frame pointer.

`leave` far√† il `POP` del push di `EBP`
```
# Esempio 1

```C
int **attribute**((stdcall)) mysum(int a, int b, int c) { 
	return a + b + c; 
} 

void test() { 
	int result = mysum(32, 64, 96);
	int expected = 32 + 64 + 96;
	printf("%d == %d\n", result, expected);
} 

int main() { 
	test(); return 0;
}
```

![[preview.webp]]

Nelle architetture x86/x86-64 con frame pointer, le variabili locali stanno SEMPRE "prima" (sotto) di EBP.

### Prologo
```assembly
push    ebp           ; Salva il base pointer
mov     ebp, esp      ; Crea nuovo frame pointer
sub     esp, 40h      ; Alloca 64 bytes per variabili locali (5 X 8)
```

### Preparazione Parametri Chiamata
```assembly
mov     dword ptr [esp+8], 96    ; 3¬∞ parametro (c = 96)
mov     dword ptr [esp+4], 64    ; 2¬∞ parametro (b = 64)
mov     dword ptr [esp], 32      ; 1¬∞ parametro (a = 32)
```

Questi sono i tre parametri passati a `mysum(32, 64, 96)`. Vengono messi sullo stack perch√© la funzione usa la convenzione `__stdcall`.

### Chiamata di funzione
```assembly
call    stdc_401460   ; Chiama mysum
sub     esp, 12       ; Pulisce i parametri (3 √ó 4 bytes)
mov     [ebp-12], eax ; Salva il risultato in var_C (result)
```
eax contiene il valore di ritorno della funzione `mysum`
L'ultima istruzione, copia il valore da eax nella memoria all'indirizzo `ebp-12` ovvero result

### Calcolo del Valore Atteso
```assembly
mov     dword ptr [ebp-16], 192  ; expected = 192 (32+64+96)
```
IDA ha ottimizzato il calcolo `32 + 64 + 96` direttamente a 192 in fase di compilazione.

### Preparazione per Printf
```assembly
mov     eax, [esp+16]    ; Carica 'expected'
mov     ecx, [ebp-16]    ; (altro accesso a expected)
mov     eax, [ebp-12]    ; Carica 'result'
mov     [esp+4], eax     ; 2¬∞ arg: result
mov     dword ptr [esp], offset Format  ; 1¬∞ arg: "%d == %d\n"
call    printf
```

### Mappatura Variabili
- `var_C` ([ebp-12]) = `result` - il valore ritornato da `mysum`
- `var_10` ([ebp-16]) = `expected` - valore precalcolato 192
- `Format` = stringa `"%d == %d\n"`

```ad-question
Perch√® ho sottratto da EBP e non da ESP?

```

```
Stack (cresce verso il basso ‚Üì) 
================================                   (INDIRIZZI ALTI (0X1000))
[parametri funzione] [indirizzo di ritorno] 
ebp ‚Üí [vecchio ebp salvato] ‚Üê Base del frame corrente     
ebp-4 [variabile locale 1] 
ebp-12 [variabile locale 2 = result] 
ebp-16 [variabile locale 3 = expected] 
esp ‚Üí [top dello stack] ‚Üê Dopo "sub esp, 40h" 
================================                   (INDIRIZZI BASSI (0X0FC0))
```

```ad-success
title: Risposta
Perch√© sottraiamo?
1. Lo stack **cresce verso il basso** (da indirizzi alti a indirizzi bassi)
2. `ebp` punta alla **base** (parte alta) del frame corrente
3. Le variabili locali vengono allocate **sotto** `ebp`, quindi verso indirizzi pi√π bassi
4. Per accedervi usiamo offset negativi: `ebp-4`, `ebp-8`, `ebp-12`, ecc.

```

```ad-important
`sub esp, 40h` stai **sottraendo** 40h (64 in decimale) da ESP, non aggiungendo!
```
## Regola fondamentale:
- **`sub esp, N`** = alloca N bytes (ESP si sposta verso il basso, indirizzi pi√π bassi)
- **`add esp, N`** = dealloca N bytes (ESP si sposta verso l'alto, indirizzi pi√π alti)

- **EBP** (Base Pointer) = punta alla **base** del frame (indirizzo alto)
- **ESP** (Stack Pointer) = punta alla **cima/top** dello stack (indirizzo basso)


```assembly
Dopo CALL test() (push automatico del return address): 

================================ 
[return address] ‚Üê Pushed automaticamente 
esp ‚Üí [qui] 
================================ 

Dopo PUSH EBP: 

================================ 
[return address] 
[vecchio ebp] ‚Üê Salvato 
esp ‚Üí [qui] ‚Üê ESP si √® abbassato di 4 
================================ 

Dopo MOV EBP, ESP: 

================================ 
[return address] 
ebp ‚Üí [vecchio ebp] ‚Üê EBP ora punta qui! 
esp ‚Üí [qui] ‚Üê ESP stesso posto 
================================ 
‚Üë Questa √® la BASE del NUOVO frame! 

Dopo SUB ESP, 40h:
 
================================ 
[return address] 
ebp ‚Üí [vecchio ebp] ‚Üê BASE (EBP fisso)
[spazio 64 bytes] 
esp ‚Üí [qui] ‚Üê TOP (ESP abbassato) 
================================
```

# Esempio 2

![[preview 1.webp]]

```C
void fun_while() {
	while (B % 4 != 0) {
		 C += A_2; 
		 B--; 
	 } 
} 

int main(int argc, char_ argv[]) { // feel free to change this as you like! 
	A = 30; B = 21; C = 3; 
	fun_while(); 
	return 0; 
}
```

### Struttura del Ciclo While
```c
while (B % 4 != 0) {
    C += A*2;
    B--;
}
```
### Prologo funzione 
```
push    ebp
mov     ebp, esp
jmp     short loc_401501    ; Salta DIRETTAMENTE alla condizione!
```
**Importante**: Il compilatore ottimizza saltando subito al controllo della condizione prima di eseguire il corpo del loop.

### Condizione del while (`loc_401501`)
```
loc_401501:
mov     eax, ds:_B          ; Carica B in eax
and     eax, 3              ; eax = B & 3  (equivale a B % 4)
test    eax, eax            ; Controlla se eax == 0
jnz     short loc_4014E0    ; Se NON zero, vai al corpo del loop (0 = false -> condizione non rispettata)
```
**Trucco di ottimizzazione**:
- `B % 4` √® sostituito con `B & 3` (pi√π veloce!)
- `x % 4 == x & 3` perch√© 4 = 2¬≤, quindi prendi gli ultimi 2 bit
- `test eax, eax` controlla se il risultato √® zero
- `jnz` = "jump if not zero" ‚Üí se `B % 4 != 0`, esegui il corpo

### Corpo del Loop (`loc_4014E0`)
```
loc_4014E0:
mov     eax, ds:_A          ; Carica A
lea     edx, [eax+eax]      ; edx = A + A = A*2 (LEA trick!)
mov     eax, ds:_C          ; Carica C
add     eax, edx            ; eax = C + A*2
mov     ds:_C, eax          ; Salva in C
mov     eax, ds:_B          ; Carica B
sub     eax, 1              ; eax = B - 1
mov     ds:_B, eax          ; Salva in B (B--)
```
**Ottimizzazioni interessanti**:
- `lea edx, [eax+eax]` = modo furbo per fare `A*2` senza moltiplicazione!
- LEA (Load Effective Address) calcola indirizzi ma qui √® usato per aritmetica veloce

### Ritorno al Controllo
Dopo il corpo, il flusso torna automaticamente a `loc_401501` per ricontrollare la condizione.

### Uscita dal Loop
```
nop
pop     ebp
retn                        ; Torna al chiamante
```
Quando `B % 4 == 0`, il `jnz` non salta e si esce dal loop.



>Remember, CPU see only a list of commands and instructions


---

# Laboratory 3
Answer the following questions: 
1) When was this file compiled? `Thu May 14 19:12:41 2009`
2) List a few imports or sets of imports and describe how the malware might use them. 
	`readfile` and `writefile`, `shellexecuteExA` (Performs an operation on a specified file.), `createpipe`
3) What are a few strings that stick out to you and why? 
	All the strings inside the blacklist. In particular GetStartupInfo because it allow to obtain useful data from the startup, also setProcessPriorityBoost and SetThreadPriority because can change the priority for a certain and specific thread/process.
4) What happens when you run this malware? Is it what you expected and why? 
	cdscs
5) Name a procmon filter and why you used it. 
6) Are there any host-based signatures? (Files, registry keys, processes or services, etc). If so, what are they? 
7) Are there any network based signatures? (URLs, packet contents. etc) If so, what are they?
8) Is there anything that impeded your analysis? How so? How might you overcome this?
9) What do you think is the purpose of this malware?

## Parte teorica
Per prima cosa analizziamo il file `lab_03-1` usando ==pestudio 8.56==. Pestudio ci fornisce un‚Äôanalisi statica rapida e dettagliata: tra le informazioni di maggior interesse ci sono le librerie importate, le stringhe contenute nel binario, le sezioni del file PE, gli export/import, le risorse e gli indicatori di sospetto (packer, anomalie nelle sezioni, ecc.). Questi elementi ci permettono di rispondere in modo documentato alle prime tre domande dell‚Äôesercizio, perch√© rivelano quali API vengono chiamate, possibili URL o comandi nascosti nelle stringhe e quali capacit√† il programma potrebbe avere (es. manipolazione di file, rete, creazione di processi, elevazione di privilegi).

Per la parte finale della lezione svolgiamo un‚Äôanalisi dinamica con ==Process Monitor (Procmon)==. Procmon cattura in tempo reale tutte le operazioni a livello di sistema: attivit√† su file, chiavi di registro, creazione/terminazione di processi, attivit√† di rete (se abilitata) e accessi alle risorse. La procedura tipica che seguiamo √®:

1. avviare Procmon per iniziare la cattura;
2. eseguire `malware.exe` (fase di esecuzione/trigger);
3. arrestare la cattura quando ritenuto sufficiente;
4. ispezionare i log raccolti.

Durante l‚Äôanalisi possiamo applicare filtri mirati per ridurre il rumore ‚Äî per esempio filtrare per **PID** del processo in esame, per nome del processo, per operazione (CreateFile, RegSetValue, CreateProcess, ecc.) o per percorso file/chiave di registro. Questo ci consente di isolare le azioni compiute dal binario infetto e seguire la catena di attivit√† (ad es. un processo che crea un file, poi avvia un altro processo, poi modifica una chiave di registro per persistenza).

Infine confrontiamo i risultati statici di **pestudio** con quelli dinamici osservati in **Process Monitor**. In pratica:
![[MW112.png]]Lab_03-1.exe is performing action process create whose target is cmd.exe and in fact, one moment later, we have this new process with PID 4772 that is our shell
![[MW113.png]]


```ad-note
title: Spiegazione parte pratica Process Monitors
**_Preparazione: Creazione di Thread e Caricamento di DLL_**
Prima dell'azione principale, il malware si sta preparando all'esecuzione.

- **`Thread Create`**: Il processo `Lab_03-1.exe` (PID: 6452) crea diversi nuovi thread (con ID 6760, 1500, 6568, etc.). Questo √® un comportamento normale per un'applicazione che vuole eseguire pi√π operazioni in parallelo.
- **`Load Image`**: Il processo carica diverse DLL di sistema nel suo spazio di memoria. Queste sono librerie legittime di Windows necessarie per funzionare (es. `wincon.dll` per la console, `WinTypes.dll` per i tipi di dati Windows). Questo indica che il malware si sta "initializzando" e preparando a usare le funzioni del sistema operativo.

**_2. L'Azione Malevola Principale: Creazione di un Processo_**
Questo √® il punto cruciale dell'analisi.
- **`Process Start`**: Alle **1:40:52.1355044 PM**, il processo `Lab_03-1.exe` (PID: 6452) avvia un **nuovo processo**.
- **Percorso del nuovo processo**: `C:\Windows\SysWOW64\cmd.exe`
- **Risultato**: **SUCCESS**
- **PID del nuovo processo**: **4772**

**Cosa significa?** Il malware ha lanciato con successo il Prompt dei comandi di Windows. Questo √® un comportamento altamente sospetto per un'applicazione comune e un classico indicatore di attivit√† malevola.

**_Analisi della Chiamata di Processo (Event Properties)_**
La finestra in basso, "Event Properties", fornisce dettagli fondamentali sull'evento di "Process Create".
- **PID: 4772**: Conferma che il nuovo processo `cmd.exe` √® stato avviato con questo ID.
- **Parent PID: 6452**: Questo √® un dato **fondamentale**. Conferma che il padre (il creatore) di `cmd.exe` √® proprio il nostro malware `Lab_03-1.exe`. Non √® un processo di sistema avviato indipendentemente.
- **Command Line**: `"C:\Windows\system32\cmd.exe" / "C:\Users\student\Desktop\Lab03\Lab_03-1.exe > nd"`

**Analisi della Command Line:**  
La riga di comando √® un po' corrotta (`/ "C:\Users...`), ma il concetto √® chiaro. Il malware sta tentando di eseguire `cmd.exe` e di reindirizzare l'output (l'operatore `>`) verso un file o un dispositivo. La presenza di una stringa di comando complessa √® un altro forte indicatore di malevolenza.


**_Collegamento con l'Analisi Statica_**
L'analista fa una nota cruciale:

> "Notare che qui √® presente una stringa che era all'interno della blacklist quando abbiamo effettuato l'analisi statica con **pestudio**!"

**Cosa significa questo collegamento?**

1. **Analisi Statica (con PEstudio)**: Prima di eseguire il malware, l'analista lo ha esaminato senza avviarlo. Strumenti come PEstudio analizzano il file binario e estraggono stringhe di testo in chiaro al suo interno. In quella fase, hanno trovato una "blacklist" di stringhe sospette (es. `"cmd.exe"`, `"powershell.exe"`, comandi di rete, etc.).
2. **Analisi Dinamica (con Process Monitor)**: Ora, durante l'esecuzione, l'analista **vede in azione** una di quelle stringhe sospette che aveva visto nella lista nera. In questo caso, la stringa √® la riga di comando che avvia `cmd.exe`.

**Questo √® il momento "Eureka!" dell'analisi:** l'ipotesi di malevolenza formulata durante l'analisi statica viene **confermata empiricamente** dall'analisi dinamica. Il malware fa esattamente ci√≤ che le sue stringhe suggerivano.

```
