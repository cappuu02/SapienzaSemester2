
# Malware under the Hood
Basic dynamic analysis focuses on externally observable behavior
Advanced static analysis focuses on malware internals
Both can fall short for different reasons
- malware evasion (e.g., analysis tools and virtual machines) 
- trigger-based behavior (e.g., packet containing a command) 
- code obfuscation and packing 
- anti-disassembly, self-modifying code 
# Debugger and Debugging

```ad-abstract
title: Debugger
Un ==debugger== è uno **strumento software** che consente di eseguire il programma in modalità controllata, **pausandone l’esecuzione (breakpoint)**, **ispezionando registri, memoria e stack**, e **modificando il flusso di esecuzione** in tempo reale.

```

Some popular debuggers:
- WinDbg
- IDA Pro and IDA Freeware
- OllyDbg, x64dbg
- immunity Debugger
- radar2 with plugins

```ad-abstract
title: Definition
Il ==debugging== è il processo di **esecuzione controllata di un programma** (in questo caso un malware) per **osservarne il comportamento, analizzare il flusso di istruzioni e individuare le operazioni che esso compie in memoria o sul sistema**.

```

A debugger facilitates execution analysis in several ways:
- step through instructions at the instruction level,
- inspect registers and memory contents,
- observe and trace function calls,
- monitor threads and handle exceptions.

The ability to both inspect and control execution yields crucial insights into program behavior. Analysts can also use a debugger to modify execution (e.g., change register values, patch code, set or remove breakpoints) to test hypotheses or bypass protections.

## Debugging in user space
Two ways to a debugging session:
1.  Load a program from the debugger
2. Attach to a running process

Desirable features:
- Inspect and alter registers (including EIP) and memory 
- Capture control flow transfers and specific instructions 
- Control threads (pause, resume) 
- Modify code

## Following Instructions
A debugger can trace one thread at a time.  
**Stepping** allows controlled execution of instructions.

- **Single-stepping** executes one instruction at a time, exactly as the CPU processes them — useful for analyzing small code sections.
- **Step into** enters a called function and executes its instructions line by line.
- **Step over** runs the called function as a whole and resumes single-stepping after it returns.
- **Step out** continues execution until the current function finishes, then pauses once control returns to the caller.

## Breakpoints
```ad-abstract
title: Definition
Breakpoints allow the program to run freely until a specific point of interest is reached.

```
### Types of Breakpoints
- **Instruction breakpoints:** pause execution when the **EIP** (Instruction Pointer) reaches a specific address.
- **Memory breakpoints:** trigger when a particular memory location is accessed:
    - on read/write,
    - on write only,
    - or on execute (similar to an instruction breakpoint).
- **Conditional breakpoints:** suspend execution only if a given condition is met (e.g., stop at `0x401130` only when `ECX = 8`).

### Implementing Breakpoints
- **Software breakpoints:**  
    Replace the first byte of an instruction with `INT 3` (`0xCC`). When executed, the CPU raises a software interrupt captured by the debugger.
    - Unlimited number of breakpoints.
    - Easily detectable by malware (e.g., checksum of `.text` section or scanning for `0xCC`).
- **Hardware breakpoints:**  
    Use CPU **debug registers** to trap execution without modifying code.
    - Limited to a few (typically four) hardware slots.
    - Stealthier and harder for malware to detect.


![[MW135.png]]

### Usage Notes
- **Conditional breakpoints** are useful for loops (e.g., stop after _N_ iterations) or function calls (e.g., condition on arguments).
    - They slow down execution even when the condition is false.
- **Memory breakpoints** can be implemented via hardware (limited to 4 bytes each) or software (by altering memory protection, less reliable).
    - Particularly effective when analyzing **packed or self-modifying malware**.

## Exceptions
Le **eccezioni** sono meccanismi di controllo del flusso usati per gestire eventi anomali (es. divisione per zero). Dal punto di vista della CPU sono trattate come interrupt: il processore interrompe l’esecuzione e invoca un handler registrato.

- I **debugger** intercettano le eccezioni per riprendere il controllo dell’esecuzione (come avviene anche con `INT` o con il flag di single-step TF in `EFLAGS`).

- Le eccezioni vengono consegnate al debugger _man mano_ che si verificano; il debugger può “vederle” fino a **due volte**:
    - **First-chance:** l’eccezione viene prima notificata al debugger e poi (se appropriato) passata al programma; è normale per errori recuperabili (es. overflow floating-point).
    - **Second-chance:** se il programma non gestisce l’eccezione (nessun handler registrato), l’eccezione ritorna al debugger: qui serve intervento (altrimenti il programma termina).

- I debugger usano eccezioni per implementare breakpoints e single-stepping; gli stessi meccanismi sono sfruttati dai malware come **tecnica anti-debug** (ad es. generare eccezioni intenzionali o confondere l’ordine di delivery per rilevare la presenza del debugger).

## Debugging and ASLR
ASLR randomizes where sections are loaded, which complicates debugging by changing addresses across runs.

- **Effect:** Binaries compiled with `/DYNAMICBASE` have their `.text` base address randomized at each execution, so disassembly addresses may not match runtime addresses.

- **IDA:** use _Manual Load_ for the PE or rebase the program for the current session (`Edit → Segments → Rebase Program`) to align static analysis with a chosen base.

- **Patch the PE header:** you can clear the DYNAMICBASE flag (e.g., via CFF Explorer: _OptionalHeader → Dll Characteristics → “DLL can move”_), but modern Windows (Windows 10+) or system policies can still override or re-enable ASLR.

![[MW136.png]]
## IDA’s Debugger
Recent versions of IDA Freeware include a debugger.
Lacks integration with third-party tools like Scylla and some advanced scripting features (so you may still consider using x64dbg sometimes!)

### Main interface
Four quadrants: 
1. Disassembler window 
2. Registers window 
3. Stack window 
4. Memory dumps window

![[MW137.png]]

### Memory Map
Layout information can be very valuable in the analysis ▪ Writable+executable regions may hint at packing or self-modifying code ▪ A changed protection for a region may suggest that as well ▪ Lists load address for DLLs ▪ Clicking on a base address will update the disassembler (code) or the memory dump (data) view

![[MW138.png]]
### Panes
 IDA offers several panes besides CPU and Memory Map:
 - Graph 
 - Breakpoints 
 - Call stack 
 - SEH (Exception handling) 
 - Symbols 
 - Threads 
 - and others…

#### Graph Pane
By right-clicking or pressing SPACE on an instruction address in the Disassembler window, we can toggle between the classic IDA view and the “flat” disassembly one.

![[MW139.png]]

### Call Stack and Threads
The Call Stack pane shows the sequence of routine calls currently active on the stack, while the Threads pane lets the analyst control the state of each thread.

![[MW140.png]]

### Managing Stepping
Fine-grained control of the execution 
- Run until a breakpoint is hit 
- Step into and step over for single-step 
- Execute till return 
- Restart the execution

![[MW141.png]]

### Controlling Breakpoints
Intuitive instruction breakpoints ▪ Toggle software breakpoints (on/off): F2 ▪ Can later enable hardware assistance ▪ Breakpoints can be controlled from pane (e.g., enable/disable/remove all) ▪ Hit count for each breakpoint ▪ Memory breakpoints are similar

![[MW142.png]]
![[MW143.png]]

### Modifying Registers
We can edit general-purpose registers (e.g., ECX) or change the instruction pointer.

![[MW144.png]]

### Modifying Memory
We can alter memory easily: we can follow an address on stack first (e.g., to dereference a pointer) or directly on dump (e.g., ASCII data), then modify the corresponding data. Experience will tell you every time!

![[MW145.png]]

### Modifying Code
We can also modify code, provided that there is enough space to host the desired new instruction(s). ▪ Changes by default do not survive restarts. But they can be imported/ exported/made permanent using patches (File->Patches) ▪ Beware of possible integrity checks ▪ Ensure stack pointer validity w.r.t. frame layout when deleting a function call!

![[MW146.png]]

### Common IDA shortcuts
Learn shortcuts to use IDA more efficiently ▪ Escape - go back to previous position in current view ▪ Ctrl+Enter - go forward to next position in current view ▪ Space - switch between text and graph mode ▪ G - jump to address in current view ▪ F2 ▪ (during static code analysis) set a breakpoint at the current instruction ▪ (during debugging) enable edit mode to change selected value, then F2 again to apply changes ▪ X - show cross referencing info for selected function entrypoint ▪ N - rename selected reference ▪ https://docs.hex-rays.com/user-guide/configuration/shortcuts (some commands may be available in Pro version only)