# What is Yara?

```ad-abstract
title: Definition
==YARA== is a powerful tool for pattern matching, primarily used in malware research and incident response to identify and classify malware samples.

```

Think of it as a vastly supercharged version of `grep`. It allows you to create descriptions of malware families based on their observable patterns.

Primary Use Cases:
- **Threat Identification:** Quickly check if a file, process memory, or network stream matches known suspicious characteristics.
- **Data Mining:** Search for specific information (like indicators of compromise - IoCs) within large datasets of files.
- **Threat Intelligence Management:** Maintain an organized library of rules for different malware families and threat actors based on observed IoCs (Indicators of Compromise).

```ad-failure
title: What YARA is not
- It is **NOT** an Antivirus engine.
    
- It is **NOT** a Host-based Intrusion Detection System (HIDS).

```

> **Key Takeaway:** YARA is a detection tool, not a real-time protection system.

A tool that you can download/compile for your OS
![[MW147.png]]

## Yara Basic Rules
At a minimum, a rule must have a name and a condition.
The simplest possible rule is: 
	`rule dummy { condition: false } `
That rule does nothing. Inversely, this rule matches on anything: 
	`rule dummy { condition: true }` 
Slightly more useful example that will match on any file over 500 KB: 
	`rule over_500kb {condition: filesize > 500KB}`

Standard structure for Yara rules:
```bash
//Modulo per riconoscere la banda dei rapinatori di banche
rule silent_banker : banker { 

//Note per i colleghi detective
meta: 
	description = "This is just an example" 
	threat_level = 3 
	in_the_wild = true 

//Segni particolari del Criminale
strings: 
	$a = {6A 40 68 00 30 00 00 6A 14 8D 91} 
	$b = {8D 4D B0 2B C1 83 C0 27 99 6A 4E 59 F7 F9} 
	$c = "UVODFRYSIHLNWPEJXQZAKCBGMT" 

//Condizione per essere arrestati
condition: 
	all of them 
}
```

==**Sezione META**==
La sezione **meta** contiene informazioni descrittive sulla regola sotto forma di coppie chiave-valore.
**Caratteristiche principali:**
- **Struttura libera:** Puoi definire qualsiasi coppia chiave-valore desideri
- **Scopo descrittivo:** Serve per documentare la regola e il tipo di contenuto che va a identificare
- **Tipi di dati supportati:**
    - Stringhe di testo (`"testo"`)
    - Numeri interi (`123`)
    - Numeri decimali (`3.14`)
    - Valori booleani (`true`/`false`)
- **Visibilit√†:** Quando una regola fa match, l'applicazione che usa YARA riceve anche questi metadati, fornendo contesto immediato

==**Sezione STRINGS**==
La sezione **strings** definisce le variabili che contengono i contenuti specifici da cercare all'interno dei file analizzati.

**Tipi di pattern disponibili:**

**1. Pattern Esadecimali**
- **Sintassi:** racchiusi tra parentesi graffe `{}`
- **Esempio:** `$a = {6A 40 68 00 30 00 00 6A 14}`
- **Caratteristiche:** Supportano wildcard (caratteri jolly) e "jumps" (intervalli variabili)
- **Utilizzo tipico:** Identificare codice macchina univoco, come routine di decompressione o scompattamento

**2. Stringhe di Testo**
- **Sintassi:** testo semplice tra virgolette
- **Esempio:** `$b = "UVODFRYSIHLNWPEJXQZAKCBGMT"`
- **Utilizzo:** Cercare sequenze testuali come password, nomi file, indirizzi, o stringhe caratteristiche

 **3. Espressioni Regolari**
- **Sintassi:** racchiuse tra barre `//`
- **Esempio:** `$c = /http:\/\/[a-z]+\.malicious\.com/`
- **Utilizzo:** Ricercare pattern complessi e flessibili che possono avere variazioni

Conditions section - define matching conditions. Example:
![[MW148.png]]

```ad-example
![[Pasted image 20251023105927.png]]

```
## Imports and Modules
Several modules can be imported
```ad-example
![[Pasted image 20251023110110.png]]

```

## References
You can reference other rules:
![[MW151.png]]



```ad-example

**Zeus** (anche noto come Zbot) √® un trojan bancario molto sofisticato che ruba credenziali bancarie, password e dati sensibili. Comunica con server C&C (Command & Control) usando un protocollo HTTP personalizzato.

![[Pasted image 20251023110247.png]]
1. **_Dichiarazione e Import_**
	- **`import "pe"`**: Importa il modulo PE che permette di analizzare la struttura dei file eseguibili Windows
	- **`rule Windows_Malware_Zeus`**: Nome della regola (identificativo univoco)
	- **`: Zeus_1134`**: **Tag/etichetta** per classificare questa regola (utile per organizzare migliaia di regole)

2. **_Sezione Meta (Metadati)_****Metadati documentali** - non influenzano la detection, ma sono cruciali per: 
	- **Tracciabilit√†**: Chi ha creato la regola e quando 
	- **Manutenzione**: Capire cosa fa la regola mesi/anni dopo 
	- **Referenze**: Link a report/analisi del malware 
	- **Collaborazione**: Altri analisti capiscono il contesto

3. **_Sezione Strings (Pattern da Cercare)_**
	- **Formato stringa** tra `""` 
	- Header HTTP **proprietari** usati da Zeus 
		- **X_ID**: Identificativo univoco del bot infetto 
		- **X_OS**: Sistema operativo della vittima (es: "Windows 7 x64") 
		- **X_BV**: Bot Version (versione del malware Zeus)
	- stringR1 = "InitializeSecurityDescriptor"
	- $stringR2 = "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; SV1)"

4. **_Sezione Condition (Logica di Detection)_**: Questa √® la **logica booleana** che determina se un file √® malware.

> La regola viene usata cos√¨: `yara Zeus_rule.yar suspicious_file.exe`

**YARA analizza il file byte per byte:**
1. ‚úÖ Controlla offset 0 ‚Üí trova `4D 5A` (MZ)
2. ‚úÖ Scansiona tutto il file ‚Üí trova "X_ID: ", "X_OS: ", "X_BV: "
3. ‚úÖ Trova "InitializeSecurityDescriptor"
4. üö® **MATCH!** ‚Üí `Windows_Malware_Zeus` (tagged: Zeus_1134)

Questa regola √® efficace:

‚úÖ **Basso tasso di falsi positivi**
- Gli header `X_ID`, `X_OS`, `X_BV` insieme sono **estremamente specifici** di Zeus
- Nessun software legittimo usa questa combinazione

‚úÖ **Difficile da evadere**
- Zeus **deve** usare questi header per comunicare con il C&C server
- Cambiare il protocollo richiederebbe modificare sia il malware che il server

‚úÖ **Veloce**
- YARA usa algoritmi efficienti (Boyer-Moore, Aho-Corasick)
- Pu√≤ scansionare migliaia di file al second
  
Identify PE files
![[Pasted image 20251023110300.png]]
```

```ad-example

Questo √® un esempio pratico di come Zeus nasconde il suo codice malevolo all'interno di strutture PE legittime, mantenendo per√≤ pattern HTTP distintivi che YARA pu√≤ rilevare.

Identify PE files:
![[Pasted image 20251023110313.png]]

```

## More advanced Cases
Obfuscated string
![[MW155.png]]

```ad-question

Can you spot any recognizable string?
```

![[MW156.png]]

![[MW157.png]]

Check MOV‚Äôs page on the Intel manual 

![[MW158.png]]
![[MW159.png]]

The single-byte mov instruction was used to conceal the string
![[MW160.png]]


Stiamo analizzando **il codice binario di un programma** (tipicamente in fase di reverse engineering o static analysis), con l‚Äôobiettivo di identificare pattern ricorrenti di istruzioni che:
- costruiscono stringhe o tabelle in memoria, un byte alla volta, o
- inizializzano dati costanti (es. tabelle di lookup, costanti di algoritmo).

```ad-success
title: Goal
individuare malware o routine sospette con regole yara, capire come e dove il programma costruisce stringhe, ecc...

```

Sequenza di **byte macchina** che codifica un‚Äôistruzione x86 specifica:
`0xC6 0x45 disp8 imm8`
Questa √® la **codifica in linguaggio macchina** di un‚Äôistruzione x86 specifica:
`MOV BYTE PTR [EBP + disp8], imm8`

Signature
- **0xC6 0x45** √® una costante (opcode e r/m8).
- **disp8 (index)** √® variabile, ma limitato a un singolo byte.
- **imm8 (character)** √® anch‚Äôesso variabile e limitato a un singolo byte.

Alcuni malware **non vogliono lasciare stringhe visibili** (come ‚Äúcmd.exe‚Äù, ‚ÄúUser-Agent‚Äù, ecc.) nel file binario per evitare detection.

Allora costruiscono le stringhe in memoria, un carattere alla volta:
```
mov byte ptr [ebp+0], 'H'
mov byte ptr [ebp+1], 'e'
mov byte ptr [ebp+2], 'l'
mov byte ptr [ebp+3], 'l'
mov byte ptr [ebp+4], 'o'

```

In linguaggio macchina, questa sequenza appare come:
```
C6 45 00 48
C6 45 01 65
C6 45 02 6C
C6 45 03 6C
C6 45 04 6F

```

Ogni riga inizia sempre con **C6 45**, poi due byte variabili (`disp8` e `imm8`).
Questo √® il pattern che la regola YARA vuole identificare

==Come rappresentare questo pattern in YARA==
Esempio di regola YARA per rilevare la sequenza:
```bash
rule single_byte_mov { 
	strings: 
		$a = { C6 45 [2] C6 45 [2] C6 45 } 
	condition: 
	$a 
}
```

Significa:
- cerca nel file binario tre occorrenze consecutive del pattern `C6 45 ?? ??`
- `[2]` equivale a due byte jolly (cio√® ‚Äúqualsiasi valore‚Äù)
- quindi √® come scrivere `C6 45 ?? ?? C6 45 ?? ?? C6 45`

```ad-attention
**Limite:** trova solo stringhe costruite con _tre caratteri_ (poche).  

```

Per riconoscere un‚Äôintera stringa pi√π lunga, si pu√≤ usare un‚Äôespressione regolare
`$a = /(\xc6\x45..){3,}/`
- `\xC6\x45` = costante iniziale del pattern
- `..` = due byte qualunque (`disp8` e `imm8`)
- `{3,}` = ripetuto almeno 3 volte (puoi alzarlo a `{5,}`, `{10,}` per maggiore affidabilit√†)

**_Example_**: Linear Congruential Generator (LCG)
$$x_{n+1} = (ax_n + c)mod \hspace{0.2cm} m$$
Used as a RNG in PoisonIvy:
![[MW161.png]]

Corresponding rule
```bash
rule has_rng { 
	strings: 
		$a = { 0F 31 } // rdtsc 
		$b = ‚Äú2891336453‚Äù // static value of parameter 
	condition: 
		all of them
}
```
Watch out for false positives!

Check for imports:
```
import "pe" 

rule potential_keylogger { 
	strings: 
		$autorun = "Software\\Microsoft\\Windows\\CurrentVersion\\Run" wide ascii 
		
		condition: 
			pe.imports("User32.dll", "SetWindowsHookEx") 
			and 
			pe.imports("User32.dll", ‚ÄúRegisterHotKey‚Äù) 
			and 
			$autorun 
}
```

Check for potentially packed software 

```bash
import "pe" 
import "math" 
rule possibly_packed { 
	meta: 
	description = "Rule to detect binaries with a big difference between section size and section vsize (after unpack). Also, it includes a big entropy and executable flags" 
	condition: 
		for any i in ( 0..pe.number_of_sections - 1):( (pe.sections[i].virtual_size > pe.sections[i].raw_data_size*2) and pe.sections[i].characteristics & SECTION_MEM_EXECUTE and math.entropy(pe.sections[i].raw_data_offset, pe.section[I].raw_data_size) >= 7 ) }
```

Check for clearly packed software
```bash
import "pe" 

rule UPX { 
	strings: 
		$upx = "UPX" 
		
	condition: 
		pe.sections[0].name contains ‚ÄúUPX0‚Äù 
		and 
		pe.sections[1].name contains ‚ÄúUPX1‚Äù 
		and 
		$upx 
}
```