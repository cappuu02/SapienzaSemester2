
# Introduction
Staying undetected is vital for malware. Dynamic analysis is necessary to face new samples surfacing daily.
- static analyses have limited capabilities
- externally observable behavior is crucial for threat identification & classification
- only few samples (e.g., new strains) undergo manual analysis

If it can detect an execution or environmental artifact, malware can deceive even the most sophisticated analysis system.
# Discrepancies

```ad-question
title: What makes an analysis system different from a victim machine?
- virtualization artifacts 
- hardware characteristics 
- Windows installation 
- applications 
- user artifacts 
- time overheads and memory footprint 

```

# Virtualization Artifacts
Una <mark style="background: #FF5582A6;">red pill</mark> è una sequenza di istruzioni progettata per rilevare se il codice sta girando all'interno di una macchina virtuale. 

Elementi usati per **_rilevare la virtualizzazione_**:
- Istruzioni che richiedono più tempo del normale (es. `cpuid`) — misurando la latenza è possibile individuare un hypervisor.
- Errata di emulazione delle istruzioni (implementazioni incomplete o comportamenti anomali).
- Informazioni di identificazione della CPU ottenute con `cpuid`.
- Tabelle del firmware di sistema (es. stringhe SMBIOS, tabelle ACPI).
- Contenuto e posizione in memoria di strutture critiche (es. Interrupt Descriptor Table).
- Stato micro-architetturale della macchina (timing, contatori hardware, ecc.).
- Porte/risorse I/O e periferiche che possono rivelare un ambiente virtualizzato.

```ad-example
title: Example CPUID
`CPUID` è un'istruzione $x86$ che restituisce informazioni sul processore scrivendole nei registri `{EAX, EBX, ECX, EDX}`.

- Prima di eseguire `CPUID` il programma inserisce nel registro `EAX` un numero (function ID). Quel numero indica quale tipo di informazione la CPU deve restituire.
    
- Se `EAX = 0x1`, il processore scrive informazioni sulle feature in `ECX`. Il **bit 31 di `ECX`** indica la presenza di un hypervisor (1 = hypervisor presente, 0 = macchina fisica reale).
    
- Se `EAX = 0x40000000`, `EBX`, `ECX` e `EDX` contengono il **brand dell’hypervisor** come stringhe ASCII (12 byte totali). Esempi comuni:
    
    - `KVMKVMKVM\0\0\0`
        
    - `Microsoft Hv`
        
    - `VMwareVMware`
        
    - `XenVMMXenVMM`
        
    - `prl hyperv`
        
    - `VboxVboxVbox`
        

Uso pratico: eseguendo `cpuid` con i suddetti `EAX` si può rilevare sia la presenza di una VM (bit 31) sia quale hypervisor è in uso (stringhe brand).

```

```ad-info
Hypervisor è **il software o firmware che crea, avvia e gestisce macchine virtuali**.

```

# Hypervisor Bit (determinare tipo di macchina)
Virtualization check: set EAX=1 and inspect 31st bit of ECX

```bash
size_t eax, ebx, ecx, edx; 
__asm__ volatile ( 
	"cpuid" 
	: "=a"(eax), "=b"(ebx), "=c"(ecx), “=d"(edx) 
	: "a"(1) 
	: "memory" ); 
printf("%d\n", (int)(ecx >> 31));
```

**_Descrizione del codice_**:
Il frammento esegue l’istruzione `cpuid` con `EAX = 1` per ottenere le feature della CPU nei registri `EAX, EBX, ECX, EDX`. Dopo la chiamata copia il valore di `ECX` in una variabile $C$ e ne estrae il **bit 31** (`ecx >> 31`), che indica la presenza di un hypervisor. Infine stampa `1` se è rilevata una VM (hypervisor presente) oppure `0` se si è su hardware fisico.
# Hypervisor Brand (determinare brand macchina)
https://rayanfam.com/topics/defeating-malware-anti-vm-techniques-cpuid-based-instructions/

![[MW183.png]]

**_Descrizione del codice_**:
Il codice esegue `CPUID` con `EAX = 0x40000000` per ottenere il **brand dell’hypervisor** nei registri `EBX`, `ECX`, `EDX`. Confronta i valori di `ECX` e `EDX` con costanti corrispondenti alla stringa `"VMwareVMware"`; se i confronti hanno successo imposta la variabile `IsUnderVM = 1`. Infine stampa il valore di `IsUnderVM` — `1` significa che il programma è in una VM VMware, `0` che non lo è (o è un altro hypervisor).

# Execution Time for CPUID
Misurare **quanto tempo impiega l’istruzione `cpuid`** per essere eseguita. Sotto un **hypervisor**, `cpuid` genera un _VM exit_ (cioè la CPU passa il controllo al Virtual Machine Monitor), introducendo una **latenza maggiore** rispetto a una macchina fisica.

- **`rdtsc`** (Read Time-Stamp Counter) legge il contatore dei cicli CPU: serve come cronometro ad alta precisione.
- Il codice legge il tempo _prima_ e _dopo_ l’esecuzione di `cpuid`.
- **`sub`** calcola la differenza tra i due tempi (latenza).
- Il risultato viene memorizzato nella variabile `elapsed`.

Il valore `elapsed` rappresenta il **numero di cicli di clock** impiegati per eseguire `cpuid`.
- Se il valore è _alto_, probabilmente il codice gira **in una VM** (perché c’è il VM-exit).
- Se è _basso_, probabilmente gira **su hardware reale**.

```
int elapsed; 
__asm__ volatile ( 
	"mov %%eax, 1;” 
	"rdtsc ;" 
	"mov %0, %%eax ;" 
	"cpuid ;" 
	"rdtsc ; " 
	"sub %0, %%eax ;" 
	"neg %0 ;" 
	: "=r"(elapsed) : 
	: "rax", "rbx", "rcx", "rdx"); 
```


# AL-KHASER: CPUID Latency
```ad-note
title: Definition
==Al-Khaser== è uno strumento open source usato per **rilevare se un programma sta girando dentro una macchina virtuale (VM)**, un **debugger** o una **sandbox**.

```

Molti malware moderni vogliono evitare di essere analizzati, quindi **controllano se stanno girando dentro una VM** (come VirtualBox o VMware). Questo perché gli analisti spesso eseguono i malware in ambienti virtuali per studiarli in sicurezza.

Al-Khaser esegue una serie di **check di rilevamento** che un malware reale potrebbe usare:
- Rilevazione di **macchine virtuali** (VMware, VirtualBox, KVM, Xen, Hyper-V, ecc.)
- Controlli di **debugger** attivi (`IsDebuggerPresent`, `NtGlobalFlag`, ecc.)
- Misure di **latenza** (come nel tuo esempio con `cpuid` e `rdtsc`)
- Ispezione di **chiavi di registro**, processi o driver tipici delle VM
- Controlli di **strumentazione o hooking** (per capire se l’esecuzione è monitorata)

In questo esempio viene utilizzato `CPUID`. Tuttavia, in una VM può causare un evento chiamato **VM Exit**, cioè un passaggio di controllo dall’OS guest all’hypervisor.   Questo aggiunge un ritardo misurabile.

![[MW184.png]]

**_Spiegazione codice_**:
La funzione misura la **latenza** introdotta dall’istruzione `cpuid` usando il contatore `RDTSC`. Esegue il test 10 volte, calcola la media dei cicli impiegati (tsc2 - tsc1) e restituisce `TRUE` se la media è **sopra una soglia** (qui ≈1000 cicli), indicando probabilmente la presenza di un **hypervisor** (VM exit); altrimenti ritorna `FALSE` (probabile esecuzione su hardware reale).


```ad-note
title: Spiegazione VM Exit
Un **VM Exit** è quando **la CPU interrompe l’esecuzione della macchina virtuale (guest)** e **passa il controllo all’hypervisor** (il programma che gestisce la VM) perché deve gestire un’operazione “sensibile”.

- Il guest esegue un’istruzione (es. `CPUID`).
    
- La CPU vede che l’istruzione deve essere gestita dall’hypervisor.
    
- Fa un **VM Exit** → salva lo stato della VM e passa il controllo all’hypervisor.
    
- L’hypervisor esegue il suo codice (es. emula l’istruzione o la modifica).
    
- Poi la CPU fa una **VM Entry** → ritorna al guest.

Questo passaggio richiede **tempo** (salvataggio e ripristino di registri, contesto ecc.). Quindi **le istruzioni che causano VM Exit impiegano più cicli CPU**. Misurando questa **latenza maggiore**, un programma può capire se gira in una VM.
```
# Hardware Characteristics
Alcuni dettagli hardware possono tradire una macchina virtuale:

- **_Elementi monitorabili_**: modello CPU e numero di core; numero e tipo di interfacce di rete (e prefissi MAC); dimensione e seriale del disco; periferiche installate (es. audio); sensori come velocità ventola o temperatura.
- **_Perché è importante_**: molte VM hanno valori anomali o riconoscibili (es. MAC vendor di hypervisor, dischi piccoli, assenza di sensori reali).
- **_Implicazione per il malware_**: codice evasivo può controllare queste proprietà per decidere se attivare il payload solo su una “vittima reale” oppure disattivarsi se si trova in un ambiente di analisi, ovvero VM.

```ad-example
Some families of MAC addresses from hypervisors:
- "`\x08\x00\x27`" (VirtualBox) 
- "`\x00\x05\x69`" (VMware) 
- "`\x00\x0C\x29`" (VMware) 
- "`\x00\x1C\x14`" (VMware) 
- "`\x00\x50\x56`" (VMware) 
- "`\x00\x1C\x42`" (Parallels) 
- "`\x00\x16\x3E`" (Xen) 


```

```ad-example
title: Speacker Check
The TeslaCrypt ransomware makes a COM-based DirectShow audio check: not only for device presence, but also invokes APIs like AddFilter to expose inaccurate emulation of the device by a malware sandbox system.

![[MW185.png]]

```

# Windows Installation
Il malware può raccogliere **informazioni di contesto** sull’installazione di Windows (come fuso orario, lingua, tempo di attività, data d’installazione, product key) per capire se il sistema è reale o una sandbox appena creata.
Inoltre, gli **hypervisor** e i loro componenti (come le _Guest Additions_ di VirtualBox) lasciano **tracce evidenti nel registro di sistema**, in processi e driver.

Parametri che il malware legge per capire quanto è naturale l'ambiente:
- timezone 
- language 
- uptime 
- install date 
- product keys 

I software di virtualizzazione come **VirtualBox**, **VMware**, **Hyper-V** lasciano **firme nel registro di sistema, nei driver e nei processi attivi**.

```ad-success
title: Important!
Usando queste informazioni, il malware:
- Rileva se è in una VM o Sandbox
- Decide se restare inattivo o comportarsi diversamente

```


```ad-example
title: VBOX & REGISTRY
Key values (HKEY_LOCAL_MACHINE):
- `HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\Logical Unit Id 0 => Identifier = "VBOX"` 
- `HARDWARE\Description\System => SystemBiosVersion = "VBOX" `
- `HARDWARE\Description\System => VideoBiosVersion = "VIRTUALBOX"`
- `HARDWARE\Description\System => SystemBiosDate = "06/23/99"`

Keys (HKEY_LOCAL_MACHINE):
- `HARDWARE\ACPI\DSDT\VBOX__`
- `HARDWARE\ACPI\FADT\VBOX__`
- `HARDWARE\ACPI\RSDT\VBOX__` 
- `SOFTWARE\Oracle\VirtualBox Guest Additions` 
- `SYSTEM\ControlSet001\Services\VBoxGuest` 
- `SYSTEM\ControlSet001\Services\VBoxMous`e 
- `SYSTEM\ControlSet001\Services\VBoxService` 
- `SYSTEM\ControlSet001\Services\VBoxSF` 
- `SYSTEM\ControlSet001\Services\VBoxVideo`

```

**_AL-KHASER: VBOX Registry Keys_**

![[MW186.png]]

**_Spiegazione del codice_**
Il codice controlla se nel **registro di sistema di Windows** sono presenti **chiavi tipiche di VirtualBox** (come driver e servizi “`VBox`”).  
Scorre una lista di chiavi note e, per ciascuna, verifica se esiste:  
- se sì → stampa che è stata trovata (probabile VM VirtualBox),  
- se no → indica che non è presente.
# Applications
The malware can check which **applications** are installed or running on the system to decide how to behave:
- **Required Condition** → Executes the payload only if it finds a certain program (e.g., target software).
- **Adversary to Disable** → Attempts to block or evade antivirus and security tools.
- **Evasion Signal** → If it detects analysis tools (such as IDA, OllyDbg, Wireshark), it can terminate itself or modify its behavior to avoid being analyzed.

```ad-important

Analysts test malware using multiple virtual machine images, each containing different applications and versions
```

# AL-KHASER: Applications
Al-Khaser checks here for common analysis tools and debuggers The Furtim malware first detects and bypasses a wide range of anti-virus products. Then, it searches for 29 tools that analysts launch manually: but instead of exiting immediately in their presence, it delays termination until a later stage of the fingerprinting process, intentionally causing frustration for analysts.

![[MW187.png]]

# User Artifacts
Il malware può controllare se il sistema mostra **tracce d’uso reale** (file aperti, cronologia, programmi installati, USB collegate, file in Documenti/Desktop).  
Una **installazione “pulita” di Windows** senza queste tracce è sospetta, perché tipica di una **sandbox o VM appena creata**.

> Le sandbox dovrebbero simulare un po’ di “usura” (wear-and-tear) per sembrare più realistiche.

# What could one monitor?
Non esiste una sandbox completamente invisibile:  
analizzando cosa i campioni di malware controllano, gli analisti possono **migliorare le sandbox** per renderle meno riconoscibili.

Il malware “parla” con il sistema usando diversi canali:
- **Istruzioni speciali**: `cpuid`, `rdtsc`, `int` → usate per misurare tempi o stato della CPU.
- **Chiamate di libreria**: accessi a file, registro, processi, driver, rete, DLL, timer ecc.
- **System call dirette**: comunicazione diretta con il kernel.
- **WMI queries**: raccolta di info tramite Windows Management Instrumentation.
- **Process environment (PEB)**: struttura interna che rivela dettagli come numero di CPU, presenza di debugger o moduli caricati.

>Il malware cerca “imperfezioni” tipiche delle sandbox (assenza di attività utente, istruzioni virtualizzate, processi sospetti) per capire se è sotto analisi e, in tal caso, **nascondersi o non attivarsi**.

# Anti-Debugging 101
```ad-note
title: Definition
Tecniche che il codice usa per **capire se è eseguito sotto un debugger**. Se trova un debugger, può cambiare comportamento o terminare per evitare l’analisi.

```

**_Meccanismi Comuni_**:
- **Funzioni di libreria**
    - `IsDebuggerPresent()`, `CheckRemoteDebuggerPresent()` → check rapido e diretto.
- **System call**
    - `NtQueryInformationProcess` (o simili) → interrogano il kernel per ottenere lo stato del processo.
- **PEB (Process Environment Block)**
    - `BeingDebugged` → flag semplice che indica un debugger.
    - `NtGlobalFlag` → contiene bandiere impostate dal debug (heap checks, etc.).
- **Tricks a basso livello**
    - `int 2d`, `sti` e altre istruzioni che si comportano diversamente sotto debugger o VM.
- **Abusi delle API / semantiche**
    - Operazioni ambigue (es. `CloseHandle` su handle già invalidi) che rivelano la presenza di un debugger quando l’API reagisce in modo diverso.
- **“Red pills”**
    - Collezioni di test (Peter Ferrie ne ha ~80) che sfruttano comportamenti osservabili sotto debug.

# NTGLOBALFLAG Check

**_Scopo_**:
- a **tecnica di anti-debugging**: rilevare se il processo è stato avviato o modificato con flag di debug/heap-check (spesso impostati da debugger o strumenti di analisi).
- Se ritorna TRUE, significa che è probabile la presenza di un **debugger o di un ambiente di analisi**, quindi il malware può decidere di non eseguire il payload o di adottare comportamenti evasivi.

![[MW188.png]]

**_Spiegazione del codice_**:
- Legge il **TEB** (**_Thread Environment Block_**) del thread e da lì prende il **PEB** (**_Process Environment Block_**) (sia per processo 32-bit che, se necessario, per il caso WoW64 anche il PEB a 64-bit).
- Da ciascun PEB legge il campo **NtGlobalFlag**.
- Applica una **maschera (`0x70`)** per verificare se alcuni bit di controllo/controllo heap sono impostati.
- Se quei bit sono presenti nel PEB 32-bit o in quello 64-bit, la funzione ritorna **TRUE** (rilevazione); altrimenti **FALSE**.

# NTGLOBALFLAG Check
Taken from Challenge 7 in Flare On series 2014: the code checks NtGlobalFlag against 0x70. Windows typically sets this value as a combination of multiple constants, and should be 0 when a debugger is not present. Compared to the C example from before, the code accesses the 32-bit PEB directly (but does not check the Wow64 PEB).

![[MW189.png]]

# AL-KHASER: CloseHandle

Serve per **rilevare la presenza di un debugger o di hook attivi**:
![[MW190.png]]

**_Spiegazione del codice_**:
Il codice prova a **chiudere un handle invalido** (non esistente) usando due funzioni:
1. **`CloseHandle()`** → API di livello utente (user-mode).
2. **`NtClose()`** → chiamata diretta al syscall di basso livello (kernel-mode).

Entrambe vengono eseguite dentro un blocco `try/except`:
- se viene generata un’**eccezione (STATUS_INVALID_HANDLE)** → ritorna `TRUE`;
- se non succede niente → ritorna `FALSE`.
# Timing Attacks $101$
Usare il **tempo** come indicatore per scoprire se un programma è eseguito in un ambiente di analisi (VM, debugger, instrumentation, sandbox). Le misure temporali rivelano interventi, emulazioni o manipolazioni del clock.

- **Misurare istruzioni**: cronometrando sequenze (es. `rdtsc` prima/dopo `cpuid`) e confrontandole con valori attesi; rileva VM e hypervisor.
- **Detect instrumentation**: timing anomalo può indicare strumenti che strumentano a livello binario (DynInst, PIN, Frida).
- **Sleep bombing / anti-sandbox**:
    - distribuire molti `Sleep()` piccoli invece di uno grande per consumare il budget di analisi;
    - verificare se il tempo è stato **accelerato** (es. host che avanza il clock per skip di sleep);
    - confrontare **più sorgenti di tempo** (RDTSC, QueryPerformanceCounter, GetTickCount, system time) per incoerenze.
- **Computazioni lunghe**: far fare al programma calcoli prolungati nelle fasi iniziali per far “scadere” il tempo dell’analista o dello strumento automatico.

# WMI Queries
```ad-note
title: Definition
**WMI (Windows Management Instrumentation)** è un componente di Windows che permette di interrogare il sistema con **query simili a SQL**, per ottenere informazioni su **hardware e software**.

```

Un malware può usare WMI per raccogliere dati sul sistema e capire se è:
- una **macchina reale** oppure
- un **ambiente virtuale / sandbox / di analisi**.

**_Esempio di query tipiche_**:
```
SELECT * FROM (below some examples of what can be checked) 
	Win32_Bios (SerialNumber) 
	Win32_PnPEntity (DeviceId) 
	Win32_NetworkAdapterConfiguration (MACAddress) 
	Win32_Processor (NumberOfCores, ProcessorId) 
	Win32_LogicalDisk (Size) 
	Win32_ComputerSystem (Model, Manufacturer) 
	Win32_NTEventLogFile (FileName - related to VBOX)
	MSACPI_ThermalZoneTemperature (CurrentTemperature)
```

## AL-KHASER: WMI WIN32_BIOS

Rilevare la presenza di una **VM o ambiente virtuale** analizzando il **SerialNumber del BIOS** ottenuto via WMI.
![[MW192.png]]

**_Spiegazione del codice_**:
- Chiama `Get("SerialNumber")` per leggere il numero di serie del BIOS.
- Se la lettura riesce (`SUCCEEDED(hRes)`) e il valore è di tipo stringa (`VT_BSTR`):
    - Confronta il testo con parole chiave come:
        - `"VMWare"`
        - `"Xen"`
        - `"Virtual"`
        - `"AMI"` (American Megatrends, tipico BIOS emulato)
        - `"0"` (VirtualBox usa seriali “0”)
- Se trova una corrispondenza, imposta `bFound = TRUE` → segnale che **è stata rilevata una macchina virtuale**.

# In-Guest Agents
Abbiamo individuato due principali superfici d’attacco:
1. gli **artefatti della tecnologia di esecuzione** (imperfezioni, overhead, effetti collaterali della virtualizzazione);
    
2. la **configurazione software** dell’ambiente di analisi.

Tuttavia, nei sistemi di sandboxing e nelle piattaforme di analisi dinamica, il fatto stesso di **operare all’interno della macchina virtuale del campione** rappresenta una vulnerabilità.

I **monitoring agent** che raccolgono informazioni sul comportamento del programma vengono infatti eseguiti nel **guest**, spesso come **DLL iniettate in spazio utente**. Le implementazioni in **kernel space** sono ormai meno comuni, principalmente a causa delle restrizioni imposte da **PatchGuard** nei sistemi Windows moderni.

# Virtual Machine Introspection
```ad-hint
**Idea:** eseguire l’analisi _fuori_ dal guest, osservando la macchina virtuale dal livello dell’hypervisor.  
Questa strategia è nata nei sistemi IDS per aumentare la resistenza ad attacchi e manomissioni mantenendo però visibilità completa sul comportamento del guest. VMI richiede però il supporto e la cooperazione del VM monitor (l’hypervisor).

```

Tre capacità fondamentali per una VMI efficace:

- **Isolation** — il monitor di analisi è isolato: il codice analizzato non può leggere né modificare il codice/stato del sistema di monitoraggio.
- **Inspection** — il monitor ha accesso completo allo stato della VM (memoria, registri, I/O, disco), così da ricostruire fedelmente il comportamento del guest.
- **Interposition** — il monitor può intercettare e intervenire su operazioni critiche del guest (es. istruzioni privilegiate, system call), permettendo di emulare, bloccare o modificare il loro effetto.

# ETHER `[CCS’08]`
`Ether` è stato uno dei primi analizzatori che ha sfruttato VT-x per costruire un sistema di analisi il più trasparente possibile, collocando l’analyzer nel VM monitor. Gli autori hanno enunciato requisiti progettuali per nascondere le inevitabili alterazioni di memoria/CPU introdotte dall’analisi:

Requisiti principali:

1. **Higher privilege** — l’analyzer gira a un livello di privilegio che il codice analizzato non può raggiungere.
2. **Privileged access to side effects** — eventuali side-effect prodotti dall’analizer devono essere visibili solo a chi ha quel livello di privilegio.
3. **Same basic instruction semantics** — l’esecuzione del guest non deve cambiare le semantiche delle istruzioni; side-effect ammessi solo in corrispondenza di eccezioni previste.
4. **Transparent exception handling** — quando si verifica un’eccezione, l’analyzer deve poter ricostruire il contesto atteso dal guest in modo coerente.
5. **Identical timing information** — le sorgenti temporali devono essere controllate: il monitor deve poter presentare al guest valori di tempo indistinguibili da quelli “reali”.

# The Semantic Gap Problem
![[MW193.png]]

>VMI methods incur a semantic gap when trying to inspect high-level concepts of the guest system such as API calls or threads (image from Ajay Kumar et al., ICPADS 2015) 

# Automatic and Manual Analysis
I sistemi basati su **Virtual Machine Introspection (VMI)** sono più complessi da implementare rispetto agli agent interni, ma risultano **molto più trasparenti**.  
Per questo, molte sandbox moderne adottano **approcci VMI o ibridi**, e **DRAKVUF** è oggi il principale riferimento nella ricerca accademica.

Tuttavia, la **VMI non sostituisce l’analisi manuale**: quando serve comprendere a fondo il comportamento di un malware, l’analista deve ancora intervenire direttamente.  
Nella pratica, gli analisti continuano a usare **macchine virtuali tradizionali** per smontare manualmente le tecniche di evasione.