Reverse engineering of the sample under analysis is performed using tools such as **IDA Pro** or similar disassemblers to examine the code in depth.  
These tools offer advanced capabilities that enable analysts to efficiently navigate through the program’s structure, locate specific code segments, and reconstruct its overall execution flow.

The **main objective** is to identify the most critical functions, understand the malware’s internal behavior, and extract the relevant **Indicators of Compromise (IoCs)**.  
For simplicity, it is assumed that the malware is **neither obfuscated nor intentionally modified** in ways that would hinder the analysis process.

# Global vs Local Variables
==Global variables== can be accessed and used by any function in a program.
==Local variables== can be accessed only by the function in which they are defined.

>Both global and local variables are declared similarly in C, but they look completely different in assembly.

## Global Variables
![[MW91.png|500]]
1. **Carica `y` in EAX:** `mov eax, dword_40CF60` (dove `dword_40CF60` è l'indirizzo di `y`, che vale 2).
2. **Somma `x`:** `add eax, dword_40C000` (aggiunge il valore di `x`, che è 1, a EAX). EAX ora contiene 3.
3. **Salva il risultato in `x`:** `mov dword_40CF60, eax` (aggiorna `x` al nuovo valore 3).
4. **Prepara e chiama `printf`:** Spinge il valore di `x` (3) e la stringa "Total = %d\n" sullo stack, poi chiama `printf`.
## Local Variables
![[MW92.png|500]]
Qui `x` e `y` sono **variabili locali** (sullo stack), non globali.

1. **Allocazione variabili:**
    - `[ebp-4]` = `x` (valore 1)
    - `[ebp-8]` = `y` (valore 2)
2. **Somma:**
    - Carica `x` in EAX: `mov eax, [ebp-4]`
    - Somma `y`: `add eax, [ebp-8]` (EAX = 3)
    - Salva risultato in `x`: `mov [ebp-4], eax`
3. **Stampa:**
    - Ricarica `x` in ECX (passaggio ridondante)
    - Spinge `x` e la stringa sullo stack
    - Chiama `printf`

```ad-tip
title: Main Difference
Le variabili vivono nello stack frame della funzione (`ebp-4` e `ebp-8`) invece che in memoria fissa.

```


# Switch
![[MW93.png]]
ebp+var_8 = $i$
`cmp` = fa il compare tra il valore immesso $i$ ed i valori corrispondenti ai casi (1,2,3...)
`jz` = jump to short loc_xxxxx (salta alla condizione relativa al caso i)

- **Casi di esecuzione:**
    - **CASE1:** `mov ecx, [ebp+var_4]` → `add ecx, 1` → stampa
    - **CASE2:** `mov edx, [ebp+var_4]` → `add edx, 2` → stampa
    - **CASE3:** `mov eax, [ebp+var_4]` → `add eax, 3` → stampa

Diagramma di uno switch all'interno di `IDA`
![[MW114.png]]

![[MW95.png]]
Invece di tanti `cmp/jz` fa:
```assembly
sub ecx, 1           ; i = i - 1 (normalizza da 0)
cmp [ebp+var_8], 3   ; controlla se i-1 > 3
ja short default     ; se sì, salta al default
jmp ds:off_401088[edx*4] ; SALTO INDIRETTO nella tabella (caso default)
```

Se non è maggiore di 3, allora:
`mov edx, [ebp+var_8]` → carica `i-1` in EDX
`jmp ds:off_401088[edx*4]` → **salto indiretto**

La **jump table** `off_401088` contiene:
```
off_401088[0] → indirizzo caso 1
off_401088[1] → indirizzo caso 2  
off_401088[2] → indirizzo caso 3
off_401088[3] → indirizzo caso 4
```

- Se `i = 1` → `i-1 = 0` → salta a `off_401088[0]` → **caso 1**
- Se `i = 2` → `i-1 = 1` → salta a `off_401088[1]` → **caso 2**
- Se `i = 3` → `i-1 = 2` → salta a `off_401088[2]` → **caso 3**
- Se `i = 4` → `i-1 = 3` → salta a `off_401088[3]` → **caso 4


![[MW115.png]]

# Arrays
![[MW116.png]]

# Structs
![[MW117.png]]

```
00401050    push    ebp
00401051    mov     ebp, esp          ; setup stack frame
00401053    push    20h               ; push 32 byte (sizeof struct) 
00401055    call    malloc            ; alloca memoria
0040105A    add     esp, 4            ; pulisce stack
0040105D    mov     dword_40EA30, eax ; salva puntatore in gms
00401062    mov     eax, dword_40EA30 ; ricarica gms in EAX
00401067    push    eax               ; push gms come parametro 
00401068    call    sub_401000        ; chiama test(gms)
0040106D    add     esp, 4            ; pulisce stack
00401070    xor     eax, eax          ; return 
00401072    pop     ebp
00401073    retn
```

# Exceptions
Exceptions are caused by errors.
When an exception occurs, execution transfers to the Structured Exception Handler.
- FS is one of the six Segment Registers.
- When an exception occurs, Windows looks in fs:0 for the stack location that stores the exception information, and then the exception handler is called. 

# Kernel vs User Modes
- Ring 0: Kernel Mode 
- Ring 3: User mode 
- Rings 1 and 2 are not used by Windows

![[MW99.png]]

## User Mode
Nearly all code runs in user mode, except OS and hardware drivers, which run in kernel mode.
User mode cannot access hardware directly (they need root privileges) 
Restricted to a subset of CPU instructions. Can only manipulate hardware through the Windows API 

## User Mode Processes
Each process has its own memory, security permissions, and resources.
If a user-mode program executes an invalid instruction and crashes, Windows can reclaim the resources and terminate the program. 

## Calling the Kernel
It is not possible to jump directly from user mode to the kernel.
SYSENTER, SYSCALL, INT 0x2E instructions use lookup tables to locate predefined functions.
	Their presence is an indicator that the code runs functions at the kernel level.

## Kernel Processes
All kernel-mode processes share the same resources and memory address space.  
As a result, fewer security checks are performed compared to user mode.  
If kernel-mode code executes an invalid instruction, the operating system may crash, resulting in a **Blue Screen of Death (BSOD)**.  
Some security solutions include components that run in kernel mode.  

>Kernel-mode malware is rarer, highly specialized (e.g., **rootkits**), and significantly more sophisticated than user-mode malware.

# The Native API
Interfacce a basso livello di windows e si trovano in ntdll.dll

>`Ntdll.dll` is very relevant and is the bridge for `Ntoslrnl.exe`

![[MW100.png]]

How it works?
`Programma → ntdll.dll → SYSCALL → Kernel`

I malware le utilizzano perché:
- **Stealth**: Meno monitorate delle Windows API normali, Più difficili da rilevare dagli antivirus
- **Potenza**: Funzionalità avanzate con accesso diretto a operazioni di sistema
- **Documentazione Limitata**: Microsoft non documenta ufficialmente
## Popular Native API calls in malware
Some Native API calls that can be used to get information about the system, processes, threads, handles, and other items:
- `NTtQuerySystemInformation `
- `NTtQueryInformationProcess` 
- `NTtQueryInformationThread` 
- `NTtQueryInformationFile` 
- `NTtQueryInformationKey` 
- Provide much more information than any available Win32 calls 

`NtContinue`
- Returns from an exception 
- Can be used to transfer execution in complicated ways 
- Used to confuse analysts and make a program more difficult to debug 

## Windows API
**Insieme di funzioni** che permettono ai programmi di interagire con Windows.
Governs how programs interact with Microsoft libraries. Concepts: 
- Types and Hungarian Notation 
- Handles 
- File System Functions 
- Special Files 

## Types and Hungarian Notation
Windows API has its own names to represent C data types 
- Such as DWORD for 32-bit unsigned integers and WORD for 16-bit unsigned integers
Hungarian Notation
- Variables that contain a 32-bit unsigned integer start with the prefix dw

![[MW101.png]]

# Handles
**Handles** — references to objects the OS has opened or created (e.g., process, menu, file, window).

- A handle is an _opaque_ identifier (like an immutable pointer) to a kernel object — you cannot perform arithmetic on it or dereference it like a normal pointer.
- You can store a handle and reuse it later in the program to refer to the same object.
- In some APIs you can test a handle against `INVALID_HANDLE_VALUE` to check validity.

```ad-example
- `HANDLE hFile` = handle a file
- `HANDLE hProcess` = handle a processo
- `HANDLE hThread` = handle a thread
- `HANDLE hMutex` = handle a mutex

```

# File System functions
`CreateFile`, `ReadFile`, `WriteFile` 
- Normal file input/output 
`CreateFileMapping`, `MapViewOfFile` 
- Frequently used by malware, loads file contents into RAM 
	- CreateFileMapping loads a file in memory 
	- MapViewOfFile returns a pointer to the base address of file in memory for access 
- Can be used to execute a file without using the Windows loader 

# Special Files
Shared files like `\\server` `\share`
- Or `\\?\server\share` 
- Disables string parsing, allows longer filenames

Namespaces 
- Special folders in the Windows file system 
- `\` Lowest namespace, contains everything 
- `\\.\` Device namespace used for direct disk input/output 
- Witty worm wrote to `\\.\PhysicalDisk1` to corrupt the disk 

Alternate Data Streams 
- Second stream of data attached to a filename 
- File.txt:otherfile.txt 
- Feature of NTFS filesystem

![[MW102.png|350]]

# Windows Registry
Store operating system and program configuration settings 
- Desktop background, mouse preferences, etc. 
Malware may use the registry for persistence 
- Making malware re-start when the system reboots 

5 root keys:
![[MW103.png]]

```ad-example
![[MW104.png]]

```

## Common registry functions
**Common Registry Functions:**

- **RegOpenKeyEx** – Opens a registry key for querying or editing.
- **RegSetValueEx** – Creates or updates a value in the registry and sets its data.
- **RegGetValue** – Retrieves the data associated with a registry value.

> Note: In documentation, the trailing `W` (for wide/Unicode) or `A` (for ASCII) is often omitted. For example, `RegOpenKeyExW` may be listed simply as `RegOpenKeyEx`.

## EX, A, AND W SUFFIXES
![[MW105.png]]

## Registry Code
![[MW106.png|500]]

![[MW107.png]]
![[MW108.png]]

# Network API
Berkeley Compatible Sockets Winsock libraries, primarily in ws2_32.dll 
Almost identical in Windows and Unix

![[MW109.png]]

# Server and client sides
**Server Side:**
- Keeps an open socket listening for incoming connections.
- Typical sequence of calls: `socket` → `bind` → `listen` → `accept`.
- Once a connection is accepted, use `send` and `recv` as needed.

**Client Side:**
- Connects to a server socket that is waiting for connections.
- Typical sequence of calls: `socket` → `connect`.
- Once connected, use `send` and `recv` as needed.

# The Wininet API
**The WinINet API**
- A higher-level API built on top of Winsock.
- Implemented in **Wininet.dll**.
- Provides support for application-layer protocols such as HTTP and FTP.

**Key Functions:**
- **InternetOpen** – Initializes the use of the WinINet API.
- **InternetOpenURL** – Opens a connection to a specified URL.
- **InternetReadFile** – Reads data from a URL.

# Transferring Execution
The `jmp` and `call` instructions transfer execution to another part of the code, but execution can also be redirected through other mechanisms, such as:

- **DLLs** – Dynamic-link libraries can be loaded and executed.
- **Processes** – Creating or injecting code into other processes.
- **Threads** – Starting new threads to run code concurrently.
- **Mutexes** – Can be used indirectly for synchronization-based execution control.
- **Services** – Code executed via Windows services.
- **Component Object Model (COM)** – Objects can trigger code execution.
- **Exceptions** – Exception handling mechanisms can redirect flow of execution.

# DLL (Dynamic Link Libraries)
**DLLs (Dynamic Link Libraries)**
- Allow multiple applications to **share code**.
- DLLs **export functions and resources** that can be used by other programs.
- Before DLLs, **static libraries** were used; they still exist but are now less common.
- Using DLLs already included in Windows reduces the size of your application.
- Software developers can also create **custom DLLs** and distribute them alongside their executables.

# How malware authors use DLLS
**How malware authors use DLLs**

- **Embed malicious code inside a DLL** — the DLL itself contains the payload.
- **Inject or load the malicious DLL into another process** to run code in the context of that process.
- **Leverage standard Windows DLLs** — almost all malware uses common Windows DLLs for basic functionality.
- **Use third‑party application DLLs** — e.g., call functions exported by a browser’s DLL (like Firefox’s) instead of the Win

# Basic DLL structure

# Processes
- Every program running on Windows executes as a **process**.
- Each process has its own resources, such as **handles** and its own **virtual memory** address space.
- A process contains one or more **threads**, which are the units of execution.
- Historically, malware commonly ran as an independent process.
- Modern malware more often runs **inside another process's context** (process injection or code‑hosting) to increase stealth and evade detection.

## Memory Management
- Each process consumes resources such as **CPU**, **file system**, and **memory**.
- The operating system allocates **memory** separately for each process.
- Even if two processes reference the same memory address, they are actually accessing **different physical locations** in RAM.
- This is managed through each process’s **virtual address space**, which provides isolation and protection between processes.

# Creating a new Process
`CreateProcess` avvia un nuovo processo e può essere usato, ad esempio, per lanciare una shell con una singola chiamata.  
Il parametro `STARTUPINFO` definisce i **handle** per gli stream standard (input, output ed error).  
Questi handle possono essere reindirizzati a un **socket** o a pipe, consentendo al nuovo processo di comunicare con un endpoint remoto e creando così una **remote shell**.

![[MW110.png]]

# Threads
Processes are containers, each holding one or more threads. Threads are the units that Windows actually executes.
- They are **independent sequences of instructions** executed by the CPU without waiting for other threads.
- Threads within the same process **share the memory space**, but each maintains its own **registers** and **stack**.

**Context**
- While running, a thread has full control of the CPU; other threads cannot modify its registers or execution state.
- When the OS performs a context switch, it saves the CPU state of the current thread in a **thread context** structure before switching to another thread.

**Creating Threads**
- `CreateThread` allows specifying a **start address** (start function) for the new thread.
- Malware authors can use threads to manipulate other processes, or to create separate threads for **input and output**, enabling communication with a running application.

## Coordination with Mutexes
==Mutexes== are global objects used for **inter-process communication** and coordination between multiple processes or threads.

- In the kernel, they are referred to as **mutants**.
- Malware often uses **hard-coded mutex names**, which can serve as reliable **indicators of compromise (IoCs)**.

**Mutex Functions**
- **WaitForSingleObject** – Grants a thread access to the mutex; other threads trying to acquire it must wait.
- **ReleaseMutex** – Releases the mutex when the thread is finished using it.
- **CreateMutex / OpenMutex** – Create a new mutex or obtain a handle to an existing mutex in another process.

## Check only one copy of malware is running
A common technique is to use a named mutex as a single‑instance guard. The program calls `OpenMutex` to check whether a mutex named `"HGL345"` already exists; if `OpenMutex` fails, it creates the mutex with `CreateMutex`. If the mutex already exists, the process knows another instance is running and can exit.

Low‑level check example (assembly idiom): after calling `OpenMutex` or `CreateMutex`, the code often tests the returned handle in `EAX` with `test eax, eax`. That instruction sets the Zero Flag (ZF) if `EAX` is zero — i.e., `EAX == 0` — which indicates the call failed. The program then branches based on the flag to create the mutex, exit, or take other actions.

![[MW111.png]]

```ad-bug
title: Fino a pagina 50 compresa!


```
