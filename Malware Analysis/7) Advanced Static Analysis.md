Reverse engineering the sample under analysis involves using tools such as IDA (or similar disassemblers) to inspect the code in detail. These programs provide advanced features that allow analysts to navigate efficiently through the code, search for specific fragments, and understand its execution flow. The goal is to identify the most relevant functions, comprehend the malware’s behavior, and extract the associated Indicators of Compromise (IoCs). For the sake of simplicity, we will assume that the malware is neither obfuscated nor intentionally altered in a way that complicates the analysis.

# Global vs Local Variables
==Global variables== can be accessed and used by any function in a program.
==Local variables== can be accessed only by the function in which they are defined.

>Both global and local variables are declared similarly in C, but they look completely different in assembly.

![[MW91.png]]
![[MW92.png]]

# Switch
![[MW93.png]]
![[MW94.png]]
![[MW95.png]]
![[MW96.png]]

# Arrays
![[MW97.png]]

# Structs
![[MW98.png]]

# Exceptions
Exceptions are caused by errors, such as division by zero or invalid memory access.
When an exception occurs, execution transfers to the Structured Exception Handler.
- FS is one of the six Segment Registers.
- When an exception occurs, Windows looks in fs:0 for the stack location that stores the exception information, and then the exception handler is called. 

# Kernel vs User Modes
- Ring 0: Kernel Mode 
- Ring 3: User mode 
- Rings 1 and 2 are not used by Windows

![[MW99.png]]

## User Mode
- Nearly all code runs in user mode 
	- Except OS and hardware drivers, which run in kernel mode
- User mode cannot access hardware directly 
- Restricted to a subset of CPU instructions 
- Can only manipulate hardware through the Windows API 

## User Mode Processes
Each process has its own memory, security permissions, and resources 
If a user-mode program executes an invalid instruction and crashes, Windows can reclaim the resources and terminate the program 

## Calling the Kernel
It is not possible to jump directly from user mode to the kernel.
SYSENTER, SYSCALL, INT 0x2E instructions use lookup tables to locate predefined functions.
	Their presence is an indicator that the code runs functions at the kernel level.

## Kernel Processes
All kernel-mode processes share the same resources and memory address space.  
As a result, fewer security checks are performed compared to user mode.  
If kernel-mode code executes an invalid instruction, the operating system may crash, resulting in a **Blue Screen of Death (BSOD)**.  
Some security solutions include components that run in kernel mode.  
Kernel-mode malware is rarer, highly specialized (e.g., **rootkits**), and significantly more sophisticated than user-mode malware.

# The Native API
A lower-level interface for interacting with Windows.  
`ntdll.dll` mediates calls between user-space applications and the kernel.  
The functions exported by `ntdll` constitute the **Native API**.  
Legitimate software rarely calls the Native API directly.  
Malware authors often prefer it because Native API calls can be more powerful and stealthy than higher-level Windows API calls.  
Documentation is sparse and limited.

>`Ntdll.dll` is very relevant and is the bridge for `Ntoslrnl.exe`

![[MW100.png]]

## Popular Native API calls in malware
Some Native API calls that can be used to get information about the system, processes, threads, handles, and other items 
- NTtQuerySystemInformation 
- NTtQueryInformationProcess 
- NTtQueryInformationThread 
- NTtQueryInformationFile 
- NTtQueryInformationKey 
- Provide much more information than any available Win32 calls 

`NtContinue`
- Returns from an exception 
- Can be used to transfer execution in complicated ways 
- Used to confuse analysts and make a program more difficult to debug 

## Windows API
Governs how programs interact with Microsoft libraries. Concepts: 
- Types and Hungarian Notation 
- Handles 
- File System Functions 
- Special Files 

## Types and Hungarian Notation
Windows API has its own names to represent C data types 
- Such as DWORD for 32-bit unsigned integers and WORD for 16-bit unsigned integers
Hungarian Notation
- Variables that contain a 32-bit unsigned integer start with the prefix dw

![[MW101.png]]

# Handles
**Handles** — references to objects the OS has opened or created (e.g., process, menu, file, window).

- A handle is an _opaque_ identifier (like an immutable pointer) to a kernel object — you cannot perform arithmetic on it or dereference it like a normal pointer.
- You can store a handle and reuse it later in the program to refer to the same object.
- In some APIs you can test a handle against `INVALID_HANDLE_VALUE` to check validity.

```ad-example
`CreateWindowEx` returns an `HWND` (a window handle). To perform operations on that window (for example, call `DestroyWindow`), pass the `HWND` returned by `CreateWindowEx`.

```

# File System functions
CreateFile, ReadFile, WriteFile 
- Normal file input/output 
CreateFileMapping, MapViewOfFile 
- Frequently used by malware, loads file contents into RAM 
	- CreateFileMapping loads a file in memory 
	- MapViewOfFile returns a pointer to the base address of file in memory for access 
- Can be used to execute a file without using the Windows loader 

# Special Files
Shared files like `\\server` `\share`
- Or `\\?\server\share` 
- Disables string parsing, allows longer filenames

Namespaces 
- Special folders in the Windows file system 
- `\` Lowest namespace, contains everything 
- `\\.\` Device namespace used for direct disk input/output 
- Witty worm wrote to `\\.\PhysicalDisk1` to corrupt the disk 

Alternate Data Streams 
- Second stream of data attached to a filename 
- File.txt:otherfile.txt 
- Feature of NTFS filesystem

![[MW102.png|350]]

# Windows Registry
Store operating system and program configuration settings 
- Desktop background, mouse preferences, etc. 
Malware may use the registry for persistence 
- Making malware re-start when the system reboots 

5 root keys:
![[MW103.png]]

```ad-example
![[Pasted image 20251014153335.png]]

```

## Common registry functions
**Common Registry Functions:**

- **RegOpenKeyEx** – Opens a registry key for querying or editing.
- **RegSetValueEx** – Creates or updates a value in the registry and sets its data.
- **RegGetValue** – Retrieves the data associated with a registry value.

> Note: In documentation, the trailing `W` (for wide/Unicode) or `A` (for ASCII) is often omitted. For example, `RegOpenKeyExW` may be listed simply as `RegOpenKeyEx`.

## EX, A, AND W SUFFIXES
![[MW105.png]]

## Registry Code
![[MW106.png|500]]

![[MW107.png]]
![[MW108.png]]

# Network API
Berkeley Compatible Sockets Winsock libraries, primarily in ws2_32.dll 
Almost identical in Windows and Unix

![[MW109.png]]

# Server and client sides
**Server Side:**

- Keeps an open socket listening for incoming connections.
- Typical sequence of calls: `socket` → `bind` → `listen` → `accept`.
- Once a connection is accepted, use `send` and `recv` as needed.

**Client Side:**

- Connects to a server socket that is waiting for connections.
- Typical sequence of calls: `socket` → `connect`.
- Once connected, use `send` and `recv` as needed.

# The Wininet API
**The WinINet API**
- A higher-level API built on top of Winsock.
- Implemented in **Wininet.dll**.
- Provides support for application-layer protocols such as HTTP and FTP.

**Key Functions:**
- **InternetOpen** – Initializes the use of the WinINet API.
- **InternetOpenURL** – Opens a connection to a specified URL.
- **InternetReadFile** – Reads data from a URL.

# Transferring Execution
The `jmp` and `call` instructions transfer execution to another part of the code, but execution can also be redirected through other mechanisms, such as:

- **DLLs** – Dynamic-link libraries can be loaded and executed.
- **Processes** – Creating or injecting code into other processes.
- **Threads** – Starting new threads to run code concurrently.
- **Mutexes** – Can be used indirectly for synchronization-based execution control.
- **Services** – Code executed via Windows services.
- **Component Object Model (COM)** – Objects can trigger code execution.
- **Exceptions** – Exception handling mechanisms can redirect flow of execution.

# DLL (Dynamic Link Libraries)
**DLLs (Dynamic Link Libraries)**
- Allow multiple applications to **share code**.
- DLLs **export functions and resources** that can be used by other programs.
- Before DLLs, **static libraries** were used; they still exist but are now less common.
- Using DLLs already included in Windows reduces the size of your application.
- Software developers can also create **custom DLLs** and distribute them alongside their executables.

# How malware authors use DLLS
**How malware authors use DLLs**

- **Embed malicious code inside a DLL** — the DLL itself contains the payload.
- **Inject or load the malicious DLL into another process** to run code in the context of that process.
- **Leverage standard Windows DLLs** — almost all malware uses common Windows DLLs for basic functionality.
- **Use third‑party application DLLs** — e.g., call functions exported by a browser’s DLL (like Firefox’s) instead of the Win

# Basic DLL structure


# Processes
- Every program running on Windows executes as a **process**.
- Each process has its own resources, such as **handles** and its own **virtual memory** address space.
- A process contains one or more **threads**, which are the units of execution.
- Historically, malware commonly ran as an independent process.
- Modern malware more often runs **inside another process's context** (process injection or code‑hosting) to increase stealth and evade detection.

## Memory Management
- Each process consumes resources such as **CPU**, **file system**, and **memory**.
- The operating system allocates **memory** separately for each process.
- Even if two processes reference the same memory address, they are actually accessing **different physical locations** in RAM.
- This is managed through each process’s **virtual address space**, which provides isolation and protection between processes.

# Creating a new Process
`CreateProcess` avvia un nuovo processo e può essere usato, ad esempio, per lanciare una shell con una singola chiamata.  
Il parametro `STARTUPINFO` definisce i **handle** per gli stream standard (input, output ed error).  
Questi handle possono essere reindirizzati a un **socket** o a pipe, consentendo al nuovo processo di comunicare con un endpoint remoto e creando così una **remote shell**.

![[MW110.png]]

# Threads
Processes are containers, each holding one or more threads. Threads are the units that Windows actually executes.
- They are **independent sequences of instructions** executed by the CPU without waiting for other threads.
- Threads within the same process **share the memory space**, but each maintains its own **registers** and **stack**.

**Context**
- While running, a thread has full control of the CPU; other threads cannot modify its registers or execution state.
- When the OS performs a context switch, it saves the CPU state of the current thread in a **thread context** structure before switching to another thread.

**Creating Threads**
- `CreateThread` allows specifying a **start address** (start function) for the new thread.
- Malware authors can use threads to manipulate other processes, or to create separate threads for **input and output**, enabling communication with a running application.

## Coordination with Mutexes
Mutexes are global objects used for **inter-process communication** and coordination between multiple processes or threads.

- In the kernel, they are referred to as **mutants**.
- Malware often uses **hard-coded mutex names**, which can serve as reliable **indicators of compromise (IoCs)**.

**Mutex Functions**
- **WaitForSingleObject** – Grants a thread access to the mutex; other threads trying to acquire it must wait.
- **ReleaseMutex** – Releases the mutex when the thread is finished using it.
- **CreateMutex / OpenMutex** – Create a new mutex or obtain a handle to an existing mutex in another process.

## Check only one copy of malware is running
A common technique is to use a named mutex as a single‑instance guard. The program calls `OpenMutex` to check whether a mutex named `"HGL345"` already exists; if `OpenMutex` fails, it creates the mutex with `CreateMutex`. If the mutex already exists, the process knows another instance is running and can exit.

Low‑level check example (assembly idiom): after calling `OpenMutex` or `CreateMutex`, the code often tests the returned handle in `EAX` with `test eax, eax`. That instruction sets the Zero Flag (ZF) if `EAX` is zero — i.e., `EAX == 0` — which indicates the call failed. The program then branches based on the flag to create the mutex, exit, or take other actions.

![[MW111.png]]


```ad-bug
title: Fino a pagina 50 compresa!


```
