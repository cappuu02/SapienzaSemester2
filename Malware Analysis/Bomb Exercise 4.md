# Lecture 4 (17-10-2025)

```ad-success
title: Goal
Consider the sample provided in the Zip archive (pwd: infected)
The sample is not malicious. You need to understand how it works, it is a game containing a few puzzles. You should be able to solve the puzzles.

**_How?_**
With the ==reverse code==!

```

# Steps
## Step 1
We first need to gather a basic understanding of the target:
- **_Did you run it?_**
	- yes, cmd open with these prompt in output "Welcome to my fiendish little bomb. You have 6 phases with which to blow yourself up. Have a nice day!"
- **_How does it behave?_**
	- On startup the program prints a greeting message that describes itself as a “bomb” with _6 phases_. It then remains active (non exiting immediately), indicating it expects further interaction. There is no other visible output until the user provides input.
- **_Does it expect any input from the command line?_**
	- **Yes.** Il messaggio iniziale e il fatto che il processo rimane aperto indicano che il programma legge dall’input standard (stdin) e probabilmente si aspetta risposte per le 6 fasi (una per fase).
- **_What happens when you try to interact with it?_**
	- **Osservato:** quando hai scritto una frase a caso, il programma ha chiuso il prompt (ossia il processo è terminato).  **Interpretazione ragionata:** questo comportamento suggerisce che l’eseguibile valuta l’input e termina se la risposta non è accettata — tipico dei _binary bomb_ didattici in cui una risposta sbagliata provoca il fallimento (termine del programma o messaggio di “boom”). È probabile che:
		- l’eseguibile legga una linea da stdin per ogni fase;
		- verifichi se la stringa corrisponde a un valore atteso;
		- se la stringa è errata il programma termina (chiude il prompt);
		- con risposte corrette probabilmente avanza alla fase successiva e, alla fine delle 6 fasi, stampa un messaggio di successo ed esce.
## Step 2
Let’s gather some initial information using the basic tools 
- Does the PE header tell you anything interesting? 
- Strings? 
- Imports?

Outcome:
## Step 3
Open the sample in IDA and try to understand its basic structure:
- Where is the main()? 
- What does it tell us about the behavior of the sample? 
- How is the general control flow organized in the sample? 
- Do you recognize code handling any of the output you have seen?

Outcome:

## Step 4
Try to overcome challenge n° 1 
- Which function handles the first challenge? 
- What does the function check? 
- What is the expected input to pass it?

Outcome:

## Step 5
Try to overcome challenge n° 2 
- Which function handles the second challenge? 
- How does the function handle input? 
- Which kind of calculation is performed in the code? 
- What is the expected input to pass it? 

Outcome:

## Step 6
Try to overcome challenge n° 3 
- Which function handles the third challenge? 
- How does the function handle input? Do you recognize any known control flow pattern? 
- Which kind of checks are made on the input? 
- What is the expected input to pass it?

Outcome:

## Step 7
Try to overcome challenge n° 4 
- Which function handles the fourth challenge? 
- Why does a function call itself? 
- Which kind of calculation does the function perform? 
- What is the expected input to pass the challenge? 

Outcome:


## Conclusion
Check the remaining challenges for further different behaviors




# IDA Pro 64-bit
## Introduction and some concepts
When we compile a program, the compiler also adds other code before the main function, that is used to set up the environment where the program will actually be executed. (run-time environment).

Entry point in IDA: `start function`
![[MW118.png]]

```ad-attention
- All the runtime setup procedures are not interesting for us!

- Skip lines of code that are not important!

- Commentare ed utilizzare variabili per ricordare parti di codice e cosa fanno!

```

Le standard library functions sono evidenziate in viola e sono utilizzate spesso (printf, strlen, ecc...)
Funzioni normali sono chiamate `sub_xxxxx` e sta a noi capire a cosa servono e cosa fanno.
![[MW119.png]]

Molto importante nei lavori di reverse code è capire il flusso di esecuzione e le chiamate ad altre funzioni! Alcuni tips:
- Le chiamate di funzioni in rosa, sono considerate funzioni note (librerie di funzioni note) `fopen`
- Prima di queste funzioni, è sempre indicato da IDA, sotto forma di commento, cosa si aspetta di ricevere quella funzione (Esempio: FileName)
- Ci sono stringhe, sotto forma di commenti, che ci fanno capire qualcosa di importante! ("`Usage: %s [<input_file>]`")

## Analyze the code
Se ho inserito nella command line due parametri allora, in output, avrò il print dell'errore e il programma terminerà (`call exit`).
![[MW120.png]]
![[MW121.png]]


Copia l'indirizzo di `argv` in `eax`
Incremento argv di 4, mi sposto al secondo parametro e sposto in `ecx`
`push ecx` nello stack (`ecx` address of the file name)
Chiamo `fopen` e il file handler viene messo in Stream (variable). 
Viene controllato se Stream è uguale a $0$: se non è uguale a zero (true) vai a sinistra altrimenti a destra!
![[MW122.png]]

Caso False del `cmp`:
Abbiamo l'errore `could't open`!
![[MW123.png]]
![[MW124.png]]

Se invece creo un file txt e lo passo come argomento avrò: 
![[MW125.png]]

Ora analizziamo il corpo principale:
![[MW133.png]]
![[MW134.png]]
Bisogna capire e saper interpretare tutte le fasi in modo chiaro e sequenziale:
### **_Phase 1:_**
![[MW126.png]]
![[MW127.png]]

>Come capire il numero di parametri che sfrutta una funzione? Vedo il numero di push (nello stack) che sono presenti prima della chiamata della funzione in questione.


```ad-attention
In assembly we don't have variables but we have only memory address!

```

```ad-success
title: Goal

La soluzione è chiaramente scritta nella funzione `Public speaking is very easy.`!
```

### **_Phase 2_**
We check and analyze the function called `check_phase_2` to understand what we need to do:
![[MW131.png]]

`Memory_buffer` is the place where we store the six integers = 28 that is 1Ch, 28 is 24+4 and 24 is six times 4 bytes. So we have 6 places for 6 integrals and other 4 bytes for the return address

`Var_20` is 20 so is 4 bytes less than `memory_buffer`

>We have a buffer and then we have a memory pointer that points $4$ bytes less than that.

`first known value: 1`

**first iteration:**
`1 ( memory_buffer[i-1] ovvero memory_buffer[0] )`
`i = 1`
`eax = 2*1 = 2`

**Second iteration:**
`i = 2`
`eax = 3 * memory_buffer[1] = 6`

**Third iteration:**
`i = 3`
`eax = 4 * memory_buffer[2] = 24`

**Fourth iteration:**
`i = 4`
`eax = 5 *memory_buffer[3] = 120`

**fifth iteration:**
`i = 5`
`eax = 6 * memory_buffer[4] = 720`

```ad-success
title: Solution
`1 2 6 24 120 720`

```

### **_Phase 3:_**
We check and analyze the function called `check_phase_3 to understand what we need to do:
![[MW132.png]]
Quando abbiamo nel nostro codice una switch condition con diversi cases, il codice avrà una serie di alternative tutte parallele. In IDA, questi sono visualizzati orizzontalmente!

In questa funzione l'utente deve inserire tre parametri, in particolare: `%d %c %d`
Il programma poi, in base al numero intero dato come input sceglie un case dello switch.

![[MW164.png|600]]

Ogni case switch verifica se `var_8` ,ovvero il primo intero inserito, è uguale a quello presente nello switch case (nel caso del case 0, fa il compare con `var_8` e `777`). se uguali continua altrimenti `BOOM`!

![[MW162.png|600]]

Successivamente confronta se `var_1`, in cui in ogni switch case è riempito con un carattere, è uguale al nostro carattere inserito come parametro!

![[MW163.png|600]]

```ad-success
title: Soluzione
Qualsiasi combinazione di un case corretta!
Ad esempio: `0 q 777` del case $0$!

```

### **_Phase 4:_** 
==Fibonacci Sequence==: take this function, execute in the debugger and look at the output, and you recognize that it's a sequence of numbers, you check the sequence all the way and you find that is the Fibonacci sequence.

### **_Phase 5_**
Per capire la soluzione di questa fase bisogna ragionare in tal modo:
1. Abbiamo la parola Giants
2. Facciamo riferimento alla tabella proposta da IDA
	![[BombPhase5.png]]
3. Prendiamo la posizione di ogni lettera nella tabella di IDA e vediamo la corrispondenza dei 4 bit meno significativi nella ASCII Table per trasformare quella lettera! Ogni lettera trovata formerà la parola della soluzione.

```ad-example
g $\to$ nella tabella IDA $\to$ 15 esima posizione
il numero 15 nella ASCII table = 00001111
prendiamo i 4 bit meno significativi $\to$ 1111
la lettera nella tabella ascii con gli stessi bit meno significativi è la o
Quindi la o è la prima lettera della parola della nostra soluzione.

```

```ad-success
title: Soluzione
`opekma`

```
