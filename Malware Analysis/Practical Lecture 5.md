<mark style="background: #FF5582A6;">Red in IDA</mark> = color for suggesting stop
Today only **_software breakpoints_**.
`wow` compatibility to run 32 bit sowftare on windows
loaded msvcrt.dll: `15:40`
per andare su un indirizzo specifico premere `G`

![[MW167.png]]
Nei registers, ciò che è in blu è cambiato, le altre no!

![[MW168.png]]
è stato fatto push `ebp` nello stack, spostato in alto di 4 byte!

Quando vado avanti con il debugger, la freccia lampeggia, perché è dove dovrebbe andare normalmente.

da minuto 34!

----
---
Understand how argument are passed in the second exercise!
![[MW169.png]]

0060FF60 top of the stack in the debugger
5:45 second recording

---
---
# DudeLocker Exercise
![[MW176.png]]
Inizialmente preparo lo stack con 1096 bytes.
Analizzo `aBriefcase` ed utilizzando undefined scopro che IDA aveva dato il tipo sbagliato alle variabili, che non sono numeri ma caratteri. Questi caratteri compongono la parole `Briefcase`

![[MW170.png|600]]
![[MW173.png]]
Ora salviamo in ogni variabile (eax, edx, ecx) 4 byte ciascuno che equivalgono a 2 lettere per ogni variabile, in quanto ogni lettera sono 2 byte.



![[MW177.png]]

Si preparano i parametri per la funzione `SHGetFolderPathW`. edx che sta nello stack contiene il puntatore al path del desktop. 

`csidl` = parametro delle funzione con codice $16$ che indica, nella documentazione, che voglio il percorso del desktop!

La funzione `SHGetFolderPathW` ottiene il path del desktop a partire dall'indirizzo specificato nello stack (edx).

>`SHGetFolderPathW`: Ottiene il percorso di una cartella identificata da un valore [CSIDL](https://learn.microsoft.com/it-it/windows/desktop/shell/csidl) .

![[MW179.png]]

Se $EAX ≠ 0$, salta
In questo caso è uguale quindi vado a destra.

`lstrlenW`
La funzione restituisce la lunghezza della stringa, espressa in caratteri.
![[MW180.png]]


![[MW181.png]]
La funzione `build_complete_briefcase_path` permette di creare il path completo ovvero:
![[MW182.png]]

Il `CreateFileW` qui non ha successo, infatti il valore dell'handler viene confrontato con `0FFFFFFh` che ci obbliga ad andare nel ramo "sbagliato" dell'esecuzione.